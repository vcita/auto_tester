# Create Appointment Test - Detailed Script

> **Status**: Generated from exploration
> **Last Updated**: 2026-01-23
> **Generated By**: Cursor AI exploration with Playwright MCP

## Initial State

- User is logged in
- Test service exists (context: `created_service_name`)
- Test client exists (context: `created_client_name`)
- Browser is on Calendar page (from _setup)

## Actions

### Step 1: Verify on Calendar Page

- **Action**: Verify
- **Target**: URL contains "/app/calendar"

**VERIFIED PLAYWRIGHT CODE**:
```python
if "/app/calendar" not in page.url:
    # Navigate to Calendar if not already there
    calendar_menu = page.get_by_text("Calendar", exact=True)
    calendar_menu.click()
    page.wait_for_url("**/app/calendar**", timeout=10000)
```

- **How verified**: Verified URL check in MCP
- **Wait for**: URL contains "/app/calendar"

### Step 2: Wait for Calendar to Load

- **Action**: Wait
- **Target**: Calendar iframe and New button

**VERIFIED PLAYWRIGHT CODE**:
```python
page.wait_for_selector('iframe[title="angularjs"]', timeout=10000)
outer_iframe = page.frame_locator('iframe[title="angularjs"]')
inner_iframe = outer_iframe.frame_locator('#vue_iframe_layout')
new_btn = inner_iframe.get_by_role('button', name='New')
new_btn.wait_for(state='visible', timeout=10000)
```

- **How verified**: Verified in MCP
- **Wait for**: New button visible

### Step 3: Click New Button

- **Action**: Click
- **Target**: "New" button in calendar header

**LOCATOR DECISION:**

| Option | Pros | Cons |
|--------|------|------|
| `inner_iframe.get_by_role('button', name='New')` | Unique, semantic | None |

**CHOSEN**: `inner_iframe.get_by_role('button', name='New')` - Unique button.

**VERIFIED PLAYWRIGHT CODE**:
```python
new_btn = inner_iframe.get_by_role('button', name='New')
new_btn.click()
# Wait for menu to appear
menu = inner_iframe.get_by_role('menu')
menu.wait_for(state='visible', timeout=5000)
```

- **How verified**: Clicked in MCP, menu appeared
- **Wait for**: Menu becomes visible
- **Fallback locators**: `inner_iframe.locator('button:has-text("New")')`

### Step 4: Select Appointment from Menu

- **Action**: Click
- **Target**: "Appointment" menu item

**LOCATOR DECISION:**

| Option | Pros | Cons |
|--------|------|------|
| `inner_iframe.get_by_role('menuitem', name='Appointment')` | Semantic, unique | None |

**CHOSEN**: `inner_iframe.get_by_role('menuitem', name='Appointment')` - Semantic.

**VERIFIED PLAYWRIGHT CODE**:
```python
appointment_option = inner_iframe.get_by_role('menuitem', name='Appointment')
appointment_option.click()
# Wait for client selection dialog
dialog = outer_iframe.get_by_role('dialog')
dialog.wait_for(state='visible', timeout=10000)
```

- **How verified**: Clicked in MCP, client selection dialog appeared
- **Wait for**: Dialog becomes visible
- **Fallback locators**: `inner_iframe.get_by_text('Appointment', exact=True)`

### Step 5: Search for Test Client

- **Action**: Type
- **Target**: Client search field
- **Value**: `{context.created_client_name}`

**LOCATOR DECISION:**

| Option | Pros | Cons |
|--------|------|------|
| `outer_iframe.get_by_role('textbox', name='Search by name, email or tag')` | Full accessible name | None |

**CHOSEN**: `outer_iframe.get_by_role('textbox', name='Search by name, email or tag')` - Unique.

**VERIFIED PLAYWRIGHT CODE**:
```python
search_field = outer_iframe.get_by_role('textbox', name='Search by name, email or tag')
search_field.click()
page.wait_for_timeout(100)
search_field.press_sequentially(client_name, delay=30)
# Wait for search results
page.wait_for_timeout(500)
```

- **How verified**: Typed in MCP, search results filtered
- **Fallback locators**: `outer_iframe.locator('input[placeholder*="Search"]')`

### Step 6: Select the Client

- **Action**: Click
- **Target**: Client in search results list

**LOCATOR DECISION:**

| Option | Pros | Cons |
|--------|------|------|
| `outer_iframe.get_by_role('button').filter(has_text=client_name)` | Dynamic matching | None |

**CHOSEN**: `outer_iframe.get_by_role('button').filter(has_text=client_name)` - Dynamic.

**VERIFIED PLAYWRIGHT CODE**:
```python
client_option = outer_iframe.get_by_role('button').filter(has_text=client_name)
client_option.wait_for(state='visible', timeout=5000)
client_option.click()
# Wait for service selection panel
page.wait_for_timeout(1000)  # Allow service panel to load
```

- **How verified**: Clicked in MCP, service selection panel appeared
- **Wait for**: Service selection panel visible

### Step 7: Search for Test Service

- **Action**: Type
- **Target**: Service search field
- **Value**: `{context.created_service_name}`

**VERIFIED PLAYWRIGHT CODE**:
```python
# Service search in the nested frame
service_search = inner_iframe.get_by_role('searchbox', name='Search')
service_search.click()
page.wait_for_timeout(100)
service_search.press_sequentially(service_name, delay=30)
page.wait_for_timeout(500)
```

- **How verified**: Typed in MCP, service list filtered
- **Fallback locators**: `inner_iframe.locator('input[placeholder*="Search"]')`

### Step 8: Select the Service

- **Action**: Click
- **Target**: Service row in service picker

**LOCATOR DECISION:**

| Option | Pros | Cons |
|--------|------|------|
| `inner_iframe.get_by_text(service_name, exact=True)` | Simple | Matches 2 elements (tooltip + label) - FAILS |
| `inner_iframe.locator('.service-item').filter(has_text=service_name)` | Unique, clicks row | Requires class knowledge |

**CHOSEN**: `inner_iframe.locator('.service-item').filter(has_text=service_name)` - Clicks the unique service row.

**VERIFIED PLAYWRIGHT CODE**:
```python
# CRITICAL: Use .service-item class to click on the service ROW, not just the text
# Using get_by_text() would match multiple elements (tooltip activator AND service label)
service_row = inner_iframe.locator('.service-item').filter(has_text=service_name)
service_row.wait_for(state='visible', timeout=5000)
service_row.click()
page.wait_for_timeout(2000)  # Allow service picker to close and appointment form to load
```

- **How verified**: Clicked in MCP, appointment form appeared with date/time options
- **Wait for**: Appointment form visible with service selected

### Step 8b: Fill required Address (when present) â€“ HEALED 2026-01-26

- **Action**: If the New Appointment dialog shows a required "Address" field under Location (e.g. when "My business address" is selected), fill it so Schedule can submit.
- **Target**: Address textbox in the appointment form

**Note**: Without this, the form does not submit and Step 10 times out waiting for the appointment in the calendar.

**VERIFIED PLAYWRIGHT CODE**:
```python
try:
    address_field = inner_iframe.get_by_role('textbox', name=re.compile(r'Address', re.IGNORECASE)).first
    address_field.wait_for(state='visible', timeout=2000)
    address_field.fill('123 Test Street')
    page.wait_for_timeout(300)
except Exception:
    try:
        inner_iframe.get_by_placeholder(re.compile(r'Address', re.IGNORECASE)).first.fill('123 Test Street')
        page.wait_for_timeout(300)
    except Exception:
        pass
# HEALED 2026-01-26: Dismiss Google Places autocomplete by blurring (Tab). Escape closes the whole modal.
page.keyboard.press('Tab')
page.wait_for_timeout(600)
try:
    pac = page.locator('.pac-container')
    if pac.count() > 0:
        pac.first.wait_for(state='hidden', timeout=2000)
except Exception:
    pass
```

### Step 9: Click Schedule Appointment

- **Action**: Click
- **Target**: "Schedule appointment" button

**LOCATOR DECISION:**

| Option | Pros | Cons |
|--------|------|------|
| `inner_iframe.get_by_role('button', name='Schedule appointment')` | Unique, semantic | None |

**CHOSEN**: `inner_iframe.get_by_role('button', name='Schedule appointment')` - Unique.

**VERIFIED PLAYWRIGHT CODE**:
```python
schedule_btn = inner_iframe.get_by_role('button', name='Schedule appointment')
schedule_btn.wait_for(state='visible', timeout=10000)
schedule_btn.click(force=True)
# Wait for calendar to update
page.wait_for_timeout(3000)
```

- **How verified**: Tab dismisses pac-container without closing modal; force=True avoids overlay intercept.
- **Wait for**: Calendar updates with new appointment

### Step 10: Verify Appointment in Calendar (Actual Data Verification)

- **Action**: Verify
- **Target**: Appointment visible in calendar grid

**NOTE**: We verify the appointment appears in the actual calendar data, NOT by checking toast messages.
Toast messages are unreliable and may not appear in all cases.

**VERIFIED PLAYWRIGHT CODE**:
```python
# The appointment appears as a menuitem in the calendar grid
appointment_in_calendar = inner_iframe.get_by_role('menuitem').filter(has_text=client_name)
appointment_in_calendar.wait_for(state='visible', timeout=15000)
```

- **How verified**: Verified in MCP, appointment block appeared with client name

## Success Verification

- **Appointment appears in calendar grid with client name** (actual data verification)
- DO NOT rely on toast messages - they are unreliable
