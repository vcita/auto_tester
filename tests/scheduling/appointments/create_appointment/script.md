# Create Appointment Test - Detailed Script

> **Status**: Generated from exploration
> **Last Updated**: 2026-01-23
> **Generated By**: Cursor AI exploration with Playwright MCP

## Initial State

- User is logged in
- Test service exists (context: `created_service_name`)
- Test client exists (context: `created_client_name`)
- Browser is on Calendar page (from _setup)

## Actions

### Step 1: Verify on Calendar Page

- **Action**: Verify
- **Target**: URL contains "/app/calendar"

**VERIFIED PLAYWRIGHT CODE**:
```python
if "/app/calendar" not in page.url:
    # Navigate to Calendar if not already there
    calendar_menu = page.get_by_text("Calendar", exact=True)
    calendar_menu.click()
    page.wait_for_url("**/app/calendar**", timeout=10000)
```

- **How verified**: Verified URL check in MCP
- **Wait for**: URL contains "/app/calendar"

### Step 2: Wait for Calendar to Load

- **Action**: Wait
- **Target**: Calendar iframe and New button

**VERIFIED PLAYWRIGHT CODE**:
```python
page.wait_for_selector('iframe[title="angularjs"]', timeout=10000)
outer_iframe = page.frame_locator('iframe[title="angularjs"]')
inner_iframe = outer_iframe.frame_locator('#vue_iframe_layout')
new_btn = inner_iframe.get_by_role('button', name='New')
new_btn.wait_for(state='visible', timeout=10000)
```

- **How verified**: Verified in MCP
- **Wait for**: New button visible

### Step 3: Click New Button

- **Action**: Click
- **Target**: "New" button in calendar header

**LOCATOR DECISION:**

| Option | Pros | Cons |
|--------|------|------|
| `inner_iframe.get_by_role('button', name='New')` | Unique, semantic | None |

**CHOSEN**: `inner_iframe.get_by_role('button', name='New')` - Unique button.

**VERIFIED PLAYWRIGHT CODE**:
```python
new_btn = inner_iframe.get_by_role('button', name='New')
new_btn.click()
# Wait for menu to appear
menu = inner_iframe.get_by_role('menu')
menu.wait_for(state='visible', timeout=5000)
```

- **How verified**: Clicked in MCP, menu appeared
- **Wait for**: Menu becomes visible

### Step 4: Select Appointment from Menu

- **Action**: Click
- **Target**: "Appointment" menu item

**LOCATOR DECISION:**

| Option | Pros | Cons |
|--------|------|------|
| `inner_iframe.get_by_role('menuitem', name='Appointment')` | Semantic, unique | None |

**CHOSEN**: `inner_iframe.get_by_role('menuitem', name='Appointment')` - Semantic.

**VERIFIED PLAYWRIGHT CODE**:
```python
appointment_option = inner_iframe.get_by_role('menuitem', name='Appointment')
appointment_option.click()
# Wait for client selection dialog
dialog = outer_iframe.get_by_role('dialog')
dialog.wait_for(state='visible', timeout=10000)
```

- **How verified**: Clicked in MCP, client selection dialog appeared
- **Wait for**: Dialog becomes visible

### Step 5: Search for Test Client

- **Action**: Type
- **Target**: Client search field
- **Value**: `{context.created_client_name}`

**LOCATOR DECISION:**

| Option | Pros | Cons |
|--------|------|------|
| `outer_iframe.get_by_role('textbox', name='Search by name, email or tag')` | Full accessible name | None |

**CHOSEN**: `outer_iframe.get_by_role('textbox', name='Search by name, email or tag')` - Unique.

**VERIFIED PLAYWRIGHT CODE**:
```python
search_field = outer_iframe.get_by_role('textbox', name='Search by name, email or tag')
search_field.click()
page.wait_for_timeout(100)  # Brief delay for focus (allowed)
search_field.press_sequentially(client_name, delay=30)
# Wait for search results (event-based)
client_option = outer_iframe.get_by_role('button').filter(has_text=client_name)
client_option.wait_for(state='visible', timeout=5000)
```

- **How verified**: Typed in MCP, search results filtered

### Step 6: Select the Client

- **Action**: Click
- **Target**: Client in search results list

**LOCATOR DECISION:**

| Option | Pros | Cons |
|--------|------|------|
| `outer_iframe.get_by_role('button').filter(has_text=client_name)` | Dynamic matching | None |

**CHOSEN**: `outer_iframe.get_by_role('button').filter(has_text=client_name)` - Dynamic.

**VERIFIED PLAYWRIGHT CODE**:
```python
client_option = outer_iframe.get_by_role('button').filter(has_text=client_name)
client_option.wait_for(state='visible', timeout=5000)
client_option.click()
# Wait for service panel to load (event-based)
inner_iframe.get_by_text('My Services').wait_for(state='visible', timeout=10000)
```

- **How verified**: Clicked in MCP, service selection panel appeared
- **Wait for**: "My Services" text visible (service panel loaded)

### Step 7: Search for Test Service

- **Action**: Type
- **Target**: Service search field
- **Value**: `{context.created_service_name}`

**VERIFIED PLAYWRIGHT CODE**:
```python
# Service search in the nested frame
service_search = inner_iframe.get_by_role('searchbox', name='Search')
service_search.click()
page.wait_for_timeout(100)  # Brief delay for focus (allowed)
service_search.press_sequentially(service_name, delay=30)
# Service list filters; service row appears (event-based wait in Step 8)
```

- **How verified**: Typed in MCP, service list filtered

### Step 8: Select the Service

- **Action**: Click
- **Target**: Service row in service picker

**LOCATOR DECISION:**

| Option | Pros | Cons |
|--------|------|------|
| `inner_iframe.get_by_text(service_name, exact=True)` | Simple | Matches 2 elements (tooltip + label) - FAILS |
| `inner_iframe.locator('.service-item').filter(has_text=service_name)` | Unique, clicks row | Requires class knowledge |

**CHOSEN**: `inner_iframe.locator('.service-item').filter(has_text=service_name)` - Clicks the unique service row.

**VERIFIED PLAYWRIGHT CODE**:
```python
# CRITICAL: Use .service-item class to click on the service ROW, not just the text
# Using get_by_text() would match multiple elements (tooltip activator AND service label)
service_row = inner_iframe.locator('.service-item').filter(has_text=service_name)
service_row.wait_for(state='visible', timeout=5000)
service_row.click()
# Wait for service picker to close and appointment form to load (event-based).
# Single detection: Schedule button by accessible name (regex) or "Schedule" only (one compound locator).
schedule_btn = inner_iframe.get_by_role('button', name=re.compile(r'Schedule\s*appointment', re.IGNORECASE)).or_(
    inner_iframe.get_by_role('button', name=re.compile(r'^Schedule$', re.IGNORECASE))
).first
schedule_btn.wait_for(state='visible', timeout=15000)
```

- **How verified**: Clicked in MCP, appointment form appeared with date/time options
- **Wait for**: Schedule button visible (appointment form loaded)

### Step 8b: Fill Address if present â€“ HEALED 2026-01-31

- **Action**: If the form shows a required "Address" field under Location, fill it so Schedule can submit.
- **Target**: Address textbox in the appointment form. Optional: form may not show Location/Address in all configs; if not present, skip (no wait, no timeout swallow).

**VERIFIED PLAYWRIGHT CODE**:
```python
# HEALED 2026-01-31: Address not always visible (e.g. Location section collapsed). Form ready = Schedule button.
# Only fill if Address is already in DOM (count-based check; no timeout swallow per Timeout Means Failure).
address_field = inner_iframe.get_by_role('textbox', name=re.compile(r'Address', re.IGNORECASE)).first
if address_field.count() > 0:
    address_field.click()
    address_field.press_sequentially('123 Test Street', delay=30)
    page.wait_for_timeout(300)  # Brief settle (allowed)
    page.keyboard.press('Tab')
    page.wait_for_timeout(500)  # Brief settle for autocomplete to dismiss (allowed)
```

### Step 9: Click Schedule Appointment

- **Action**: Click
- **Target**: "Schedule appointment" button (same single compound locator as Step 8)

**VERIFIED PLAYWRIGHT CODE**:
```python
schedule_btn = inner_iframe.get_by_role('button', name=re.compile(r'Schedule\s*appointment', re.IGNORECASE)).or_(
    inner_iframe.get_by_role('button', name=re.compile(r'^Schedule$', re.IGNORECASE))
).first
schedule_btn.wait_for(state='visible', timeout=10000)
schedule_btn.click(force=True)
# Wait for appointment to appear in calendar (event-based in Step 10)
appointment_in_calendar = inner_iframe.get_by_role('menuitem').filter(has_text=client_name)
appointment_in_calendar.wait_for(state='visible', timeout=15000)
```

- **How verified**: Tab dismisses pac-container without closing modal; force=True avoids overlay intercept.
- **Wait for**: Appointment visible in calendar (event-based, long timeout)

### Step 10: Verify Appointment in Calendar (Actual Data Verification)

- **Action**: Verify
- **Target**: Appointment visible in calendar grid

**NOTE**: We verify the appointment appears in the actual calendar data, NOT by checking toast messages.
Toast messages are unreliable and may not appear in all cases.

**VERIFIED PLAYWRIGHT CODE**:
```python
# The appointment appears as a menuitem in the calendar grid
appointment_in_calendar = inner_iframe.get_by_role('menuitem').filter(has_text=client_name)
appointment_in_calendar.wait_for(state='visible', timeout=15000)
```

- **How verified**: Verified in MCP, appointment block appeared with client name

## Success Verification

- **Appointment appears in calendar grid with client name** (actual data verification)
- DO NOT rely on toast messages - they are unreliable
