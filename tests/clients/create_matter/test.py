# Auto-generated from script.md
# Last updated: 2026-01-21
# Source: tests/clients/create_matter/script.md
# Generated by: Cursor AI exploration with Playwright MCP
# Note: "Matter" is vcita's general entity - called "Property" for Home Services, "Patient" for Healthcare, etc.

import re
import time
import random
from playwright.sync_api import Page, expect


def generate_test_data() -> dict:
    """Generate comprehensive random test data for matter creation."""
    timestamp = int(time.time())
    first_name = random.choice(["Test", "John", "Jane", "Alex", "Sam"])
    last_name = f"Matter{timestamp}"
    email = f"test_{timestamp}@vcita-test.com"
    # Phone number without special characters (the field strips them)
    phone = f"555{random.randint(1000000, 9999999)}"
    contact_address = f"{random.randint(100, 999)} Test Street, Test City"
    matter_address = f"{random.randint(100, 999)} Property Lane, Property Town"
    matter_type = random.choice(["Residential", "Commercial"])
    help_request = "Looking for regular lawn maintenance and landscaping services"
    special_instructions = f"Please call before arriving. Gate code: {random.randint(1000, 9999)}"
    private_notes = f"VIP customer - Test automation record. Created: {timestamp}"
    referred_by = random.choice(["Google Search", "Facebook", "Friend Referral", "Website"])
    
    return {
        "first_name": first_name,
        "last_name": last_name,
        "full_name": f"{first_name} {last_name}",
        "email": email,
        "phone": phone,
        "contact_address": contact_address,
        "matter_address": matter_address,
        "matter_type": matter_type,
        "help_request": help_request,
        "special_instructions": special_instructions,
        "private_notes": private_notes,
        "referred_by": referred_by,
    }


def test_create_matter(page: Page, context: dict) -> None:
    """
    Test: Create Matter via Quick Actions
    
    Creates a new matter using the Quick Actions menu
    with comprehensive test data including all contact and matter fields.
    
    Note: "Matter" is vcita's general entity - this account uses "Properties" (Home Services vertical)
    
    Saves to context:
    - created_matter_name: The full name of the created matter
    - created_matter_email: The email of the created matter
    - created_matter_id: The ID extracted from the URL (for delete test)
    """
    # Generate test data
    test_data = generate_test_data()
    
    # ========== PART 1: Open the New Matter Form ==========
    
    print("  Step 1: Ensuring we're on the dashboard...")
    # Make sure we're on the dashboard - after login we should be here
    # but explicitly navigate if needed
    if "/app/dashboard" not in page.url:
        page.goto("https://app.vcita.com/app/dashboard")
    
    # Wait for dashboard to fully load
    page.wait_for_load_state("domcontentloaded")
    
    print("  Step 2: Opening Quick Actions menu...")
    # Click the Quick Actions BUTTON in the sidebar to open the dropdown menu
    # The Quick Actions panel in the right sidebar doesn't respond to clicks properly
    quick_actions_btn = page.get_by_role("button", name="Quick Actions")
    quick_actions_btn.wait_for(state="visible", timeout=10000)
    quick_actions_btn.click()
    
    # Wait for the dropdown menu to appear
    page.wait_for_selector("text=PROPERTIES", timeout=5000)
    page.wait_for_timeout(500)  # Wait for animation
    
    print("  Step 3: Clicking Add property in menu...")
    # Click "Add property" in the dropdown menu (under PROPERTIES section)
    # The element has id="client" in the Quick Actions dropdown
    add_property = page.locator("#client")
    add_property.wait_for(state="visible", timeout=5000)
    add_property.click()
    
    print("  Step 4: Waiting for property form iframe...")
    # Wait for form/dialog to appear in iframe
    # The form appears in an iframe with title="angularjs"
    page.wait_for_selector('iframe[title="angularjs"]', timeout=15000)
    page.wait_for_timeout(2000)  # Extra wait for iframe content to load
    
    # Get the iframe containing the form
    iframe = page.frame_locator('iframe[title="angularjs"]')
    
    # Wait for form content to be ready (the dialog with First Name field)
    print("  Step 5: Waiting for form content (First Name field)...")
    iframe.locator('text=First Name').wait_for(timeout=15000)
    
    # Step 3: Click "Show more" to expand all contact fields
    # This button must be visible and clicked to access Referred By field
    show_more_btn = iframe.get_by_role("button", name="Show more")
    show_more_btn.click()
    page.wait_for_timeout(300)
    
    # ========== PART 2: Fill Contact Information ==========
    # Note: Email and Mobile phone fields become comboboxes (autocomplete) when focused
    # Using press_sequentially for realistic user simulation
    
    print("  Step 6: Filling contact information...")
    # Step 4: Fill First Name (required)
    first_name_field = iframe.get_by_role("textbox", name="First Name *")
    first_name_field.click()
    first_name_field.press_sequentially(test_data["first_name"], delay=50)
    
    # Step 5: Fill Last Name
    last_name_field = iframe.get_by_role("textbox", name="Last Name")
    last_name_field.click()
    last_name_field.press_sequentially(test_data["last_name"], delay=50)
    
    # Step 6: Fill Email (becomes combobox when focused)
    # Click first, then type - the field transforms to combobox on focus
    email_field = iframe.get_by_role("textbox", name="Email")
    email_field.click()
    page.wait_for_timeout(100)  # Wait for field transformation
    # Now it's a combobox, type into it
    iframe.get_by_role("combobox", name="Email").press_sequentially(test_data["email"], delay=30)
    
    # Step 7: Fill Mobile Phone (becomes combobox when focused)
    phone_field = iframe.get_by_role("textbox", name="Mobile phone")
    phone_field.click()
    page.wait_for_timeout(100)  # Wait for field transformation
    # Now it's a combobox, type into it
    iframe.get_by_role("combobox", name="Mobile phone").press_sequentially(test_data["phone"], delay=30)
    
    # Step 8: Fill Address (contact address) - has Google Places autocomplete
    # Use first one to avoid conflict with Property address
    address_field = iframe.get_by_label("Address").first
    address_field.click()
    address_field.press_sequentially(test_data["contact_address"], delay=30)
    # Dismiss autocomplete by clicking another field (not Escape - that closes the form!)
    
    # Step 9: Fill Referred By (only visible after "Show more" click)
    referred_field = iframe.get_by_role("textbox", name="Referred by")
    referred_field.click()  # This also dismisses the address autocomplete
    referred_field.press_sequentially(test_data["referred_by"], delay=50)
    
    # ========== PART 3: Fill Matter Details ==========
    print("  Step 10: Filling property details...")
    # Step 10: Fill Matter Address (Property address in this vertical)
    # Has Google Places autocomplete
    matter_address_field = iframe.get_by_role("textbox", name="Property address")
    matter_address_field.click()
    matter_address_field.press_sequentially(test_data["matter_address"], delay=30)
    
    # Step 11: Fill Help Request (also dismisses Property address autocomplete)
    help_field = iframe.get_by_role("textbox", name="How can we help you?")
    help_field.click()  # Dismisses any autocomplete dropdown
    help_field.press_sequentially(test_data["help_request"], delay=20)
    
    # Step 12: Select Matter Type from dropdown
    print(f"  Step 12: Selecting Property type: {test_data['matter_type']}...")
    matter_type_dropdown = iframe.get_by_role("listbox", name="Property type")
    matter_type_dropdown.click()
    page.wait_for_timeout(500)  # Wait for dropdown animation
    # Use get_by_role("option") to select from the dropdown
    option = iframe.get_by_role("option", name=test_data["matter_type"])
    option.wait_for(state="visible", timeout=5000)
    option.click()
    page.wait_for_timeout(300)  # Wait for selection to register
    
    # Step 13: Fill Special Instructions
    instructions_field = iframe.get_by_role("textbox", name="Special instructions/requests")
    instructions_field.click()
    instructions_field.press_sequentially(test_data["special_instructions"], delay=20)
    
    # Step 14: Fill Private Notes
    notes_field = iframe.get_by_role("textbox", name="Private notes")
    notes_field.click()
    notes_field.press_sequentially(test_data["private_notes"], delay=20)
    
    # ========== PART 4: Save and Verify ==========
    
    # Step 15: Click Save Button
    iframe.get_by_role("button", name="Save").click()
    
    # Wait for save to complete - the dialog should close and redirect to client page
    page.wait_for_timeout(2000)  # Wait for save to process
    page.wait_for_url(re.compile(r"/app/clients/"), timeout=15000)
    page.wait_for_timeout(1000)  # Additional wait for UI to settle
    
    # ========== VERIFICATION ==========
    
    # Verify URL contains matter ID
    expect(page).to_have_url(re.compile(r"/app/clients/[a-z0-9]+"), timeout=10000)
    
    # Extract matter ID from URL
    url = page.url
    matter_id_match = re.search(r'/app/clients/([^/]+)', url)
    matter_id = matter_id_match.group(1) if matter_id_match else None
    
    # Wait for page content to load
    page.wait_for_load_state("domcontentloaded")
    page.wait_for_timeout(2000)
    
    print(f"  Step 15: Verifying created matter: {test_data['full_name']}...")
    
    # Verify the client name appears in the page title
    # The client detail page has title format: "Property / {Name} | vcita"
    # NOTE: page.get_by_text() doesn't search inside iframes - the client page uses iframes
    # So we verify using the page title instead which contains the client name
    expect(page).to_have_title(re.compile(re.escape(test_data["full_name"])), timeout=15000)
    
    # Save to context for later tests (especially delete_matter test)
    context["created_matter_name"] = test_data["full_name"]
    context["created_matter_email"] = test_data["email"]
    context["created_matter_id"] = matter_id
    
    print(f"  [OK] Created matter: {test_data['full_name']}")
    print(f"     Email: {test_data['email']}")
    print(f"     Phone: {test_data['phone']}")
    print(f"     Contact Address: {test_data['contact_address']}")
    print(f"     Matter Address: {test_data['matter_address']}")
    print(f"     Matter Type: {test_data['matter_type']}")
    print(f"     Referred By: {test_data['referred_by']}")
    print(f"     Matter ID: {matter_id}")


# For standalone testing
if __name__ == "__main__":
    from playwright.sync_api import sync_playwright
    import sys
    import os
    
    # Add project root to path
    project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
    sys.path.insert(0, project_root)
    
    # Import login function
    from tests._functions.login.test import fn_login
    
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=False)
        browser_context = browser.new_context()
        page = browser_context.new_page()
        context = {}
        
        try:
            # Login first
            print("Logging in...")
            fn_login(page, context, username="itzik+autotest@vcita.com", password="vcita123")
            print("Login successful!")
            
            # Run the test
            print("\nCreating new matter with comprehensive data...")
            test_create_matter(page, context)
            print("\n✅ Test passed!")
            print(f"\nSaved to context:")
            print(f"  - created_matter_name: {context.get('created_matter_name')}")
            print(f"  - created_matter_email: {context.get('created_matter_email')}")
            print(f"  - created_matter_id: {context.get('created_matter_id')}")
            
            # Keep browser open for inspection
            input("\nPress Enter to close browser...")
            
        except Exception as e:
            print(f"\n❌ Test failed: {e}")
            page.screenshot(path="create_matter_error.png")
            raise
        finally:
            browser.close()
