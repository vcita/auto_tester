# Auto-generated from script.md
# Last updated: 2026-01-21
# Source: tests/clients/create_matter/script.md
# Generated by: Cursor AI exploration with Playwright MCP
# Note: "Matter" is vcita's general entity - called "Property" for Home Services, "Patient" for Healthcare, etc.

import re
import time
import random
from playwright.sync_api import Page, expect

from tests._functions._config import get_base_url
from tests._params import ADD_MATTER_TEXT_REGEX, MATTER_ENTITY_NAMES


def generate_test_data() -> dict:
    """Generate comprehensive random test data for matter creation.
    Uses short suffix (6 digits) so displayed name fits in table without ellipsis."""
    timestamp = int(time.time())
    first_name = random.choice(["Test", "John", "Jane", "Alex", "Sam"])
    last_name = f"Matter{timestamp % 1000000}"
    email = f"test_{timestamp}@vcita-test.com"
    # Phone number without special characters (the field strips them)
    phone = f"555{random.randint(1000000, 9999999)}"
    contact_address = f"{random.randint(100, 999)} Test Street, Test City"
    matter_address = f"{random.randint(100, 999)} Property Lane, Property Town"
    matter_type = random.choice(["Residential", "Commercial"])
    help_request = "Looking for regular lawn maintenance and landscaping services"
    special_instructions = f"Please call before arriving. Gate code: {random.randint(1000, 9999)}"
    private_notes = f"VIP customer - Test automation record. Created: {timestamp}"
    referred_by = random.choice(["Google Search", "Facebook", "Friend Referral", "Website"])
    
    return {
        "first_name": first_name,
        "last_name": last_name,
        "full_name": f"{first_name} {last_name}",
        "email": email,
        "phone": phone,
        "contact_address": contact_address,
        "matter_address": matter_address,
        "matter_type": matter_type,
        "help_request": help_request,
        "special_instructions": special_instructions,
        "private_notes": private_notes,
        "referred_by": referred_by,
    }


def test_create_matter(page: Page, context: dict) -> None:
    """
    Test: Create Matter via Quick Actions
    
    Creates a new matter using the Quick Actions menu
    with comprehensive test data including all contact and matter fields.
    
    Note: "Matter" is vcita's general entity - this account uses "Properties" (Home Services vertical)
    
    Saves to context:
    - created_matter_name: The full name of the created matter
    - created_matter_email: The email of the created matter
    - created_matter_id: The ID extracted from the URL (for delete test)
    """
    # Generate test data
    test_data = generate_test_data()
    
    # ========== PART 1: Open the New Matter Form ==========
    # HEALED 2026-01-26: Do NOT use page.goto(base_url + "/app/dashboard"). base_url is www.vcita.com;
    # www.vcita.com/app/dashboard is unavailable (app is on app.vcita.com). Setup leaves us on
    # app.vcita.com/app/dashboard after login. If not on dashboard, navigate via UI only.
    base_url = get_base_url(context)
    print("  Step 1: Ensuring we're on dashboard...")
    if "/app/dashboard" not in page.url:
        dashboard_link = page.get_by_text("Dashboard", exact=True)
        dashboard_link.click()
        page.wait_for_url("**/app/dashboard**", timeout=30000)  # Long timeout for slow systems, continues immediately when URL matches
    page.wait_for_load_state("domcontentloaded")
    # Dashboard content (Quick actions, Add property) is inside an iframe. HEALED 2026-01-30: Do not
    # use frame_locator('iframe[title="angularjs"]') — multiple such iframes can exist and the first
    # may be hidden, so we'd wait in the wrong frame. Use page-level get_by_text("Quick actions") so
    # Playwright finds the visible panel in any frame, then scope within that document.
    print("  Step 2: Waiting for Quick actions panel and Add matter button...")
    quick_section = page.get_by_text("Quick actions", exact=True).locator("../..")
    add_matter_locator = quick_section.get_by_text(ADD_MATTER_TEXT_REGEX)
    add_matter_locator.wait_for(state="visible", timeout=30000)
    # System bug: click on Add matter right after visibility can be ignored/queued. Settle allows
    # the panel to accept the click. Queued for fixing; keep this wait until resolved.
    page.wait_for_timeout(2500)

    # HEALED 2026-01-30: Click the clickable parent, not the inner text node. get_by_text() can resolve
    # to the inner element; the actual click handler is on the parent (cursor=pointer). Clicking the
    # parent reliably opens the form; MCP confirmed the parent opens the form.
    add_matter_clickable = add_matter_locator.locator("..")
    print("  Step 3: Clicking Add matter...")
    add_matter_clickable.scroll_into_view_if_needed()
    page.wait_for_timeout(300)
    add_matter_clickable.click()

    print("  Step 4: Waiting for property form (opened by Add matter click)...")
    # Form loads in a nested iframe after the click. Do NOT wait in the pre-existing vue_iframe_layout
    # (dashboard frame) — it already exists and does not contain the form until the SPA navigates.
    # Wait only for "First Name" to appear in any frame; that happens when the form has actually opened.
    def _find_form_frame():
        for frame in page.frames:
            try:
                if frame.locator('text=First Name').count() > 0:
                    return frame
            except Exception:
                pass
        return None

    def _wait_form_in_any_frame(timeout_ms: int):
        """Wait for 'First Name' to be visible in any frame; return that frame or None."""
        per_frame_ms = 500
        max_passes = max(4, timeout_ms // 4000)
        for _ in range(max_passes):
            for frame in page.frames:
                try:
                    frame.locator('text=First Name').wait_for(state='visible', timeout=per_frame_ms)
                    return frame
                except Exception:
                    continue
        return None

    form_frame = _wait_form_in_any_frame(timeout_ms=20000)

    if not form_frame:
        print("  DEBUG: Available frames:")
        for i, frame in enumerate(page.frames):
            url_preview = (frame.url[:50] + "...") if len(frame.url) > 50 else frame.url
            print(f"    [{i}] name='{frame.name}', url='{url_preview}'")
        raise Exception("Could not find form frame with 'First Name' field")

    # Ensure form content is visible (immediate when we found it in _wait_form_in_any_frame)
    form_frame.locator('text=First Name').wait_for(state='visible', timeout=15000)
    print("  Step 5: Form ready (First Name field visible).")
    
    # Step 6: Click "Show more" to expand all contact fields
    # This button must be visible and clicked to access Referred By field
    show_more_btn = form_frame.get_by_role("button", name="Show more")
    show_more_btn.click()
    # Wait for the Referred by field to become visible (indicates expansion complete)
    referred_field_check = form_frame.get_by_role("textbox", name="Referred by")
    referred_field_check.wait_for(state="visible", timeout=30000)  # Long timeout for slow systems, continues immediately when field appears
    
    # ========== PART 2: Fill Contact Information ==========
    # Note: Email and Mobile phone fields become comboboxes (autocomplete) when focused
    # Using press_sequentially for realistic user simulation
    
    print("  Step 7: Filling contact information...")
    # Fill First Name (required)
    first_name_field = form_frame.get_by_role("textbox", name="First Name *")
    first_name_field.click()
    first_name_field.press_sequentially(test_data["first_name"], delay=50)
    
    # Fill Last Name
    last_name_field = form_frame.get_by_role("textbox", name="Last Name")
    last_name_field.click()
    last_name_field.press_sequentially(test_data["last_name"], delay=50)
    
    # Fill Email (becomes combobox when focused)
    # Click first, then type - the field transforms to combobox on focus
    email_field = form_frame.get_by_role("textbox", name="Email")
    email_field.click()
    page.wait_for_timeout(100)  # Wait for field transformation
    # Now it's a combobox, type into it
    form_frame.get_by_role("combobox", name="Email").press_sequentially(test_data["email"], delay=30)
    
    # Fill Mobile Phone (becomes combobox when focused)
    phone_field = form_frame.get_by_role("textbox", name="Mobile phone")
    phone_field.click()
    page.wait_for_timeout(100)  # Wait for field transformation
    # Now it's a combobox, type into it
    form_frame.get_by_role("combobox", name="Mobile phone").press_sequentially(test_data["phone"], delay=30)
    
    # Fill Address (contact address) - has Google Places autocomplete
    # Use first one to avoid conflict with Property address
    address_field = form_frame.get_by_label("Address").first
    address_field.click()
    address_field.press_sequentially(test_data["contact_address"], delay=30)
    # Dismiss autocomplete by clicking another field (not Escape - that closes the form!)
    
    # Fill Referred By (only visible after "Show more" click)
    referred_field = form_frame.get_by_role("textbox", name="Referred by")
    referred_field.click()  # This also dismisses the address autocomplete
    referred_field.press_sequentially(test_data["referred_by"], delay=50)
    
    # ========== PART 3: Fill Matter Details ==========
    print("  Step 8: Filling property details...")
    # Fill Matter Address (entity-agnostic: "Property address", "Client address", etc.)
    # HEALED 2026-01-27: Use entity-agnostic pattern for form labels that vary by vertical.
    # Try common entity names + " address" to find the field.
    matter_address_field = None
    for entity in MATTER_ENTITY_NAMES:
        try:
            field = form_frame.get_by_role("textbox", name=f"{entity.capitalize()} address")
            if field.count() > 0:
                matter_address_field = field
                break
        except:
            pass
    if not matter_address_field:
        # Fallback: try regex pattern matching any entity + " address"
        entity_pattern = "|".join([e.capitalize() for e in MATTER_ENTITY_NAMES])
        matter_address_field = form_frame.get_by_role("textbox", name=re.compile(rf"({entity_pattern}) address", re.IGNORECASE))
    matter_address_field.click()
    matter_address_field.press_sequentially(test_data["matter_address"], delay=30)
    
    # Fill Help Request (also dismisses address autocomplete)
    help_field = form_frame.get_by_role("textbox", name="How can we help you?")
    help_field.click()  # Dismisses any autocomplete dropdown
    help_field.press_sequentially(test_data["help_request"], delay=20)
    
    # Select Matter Type from dropdown (entity-agnostic: "Property type", "Client type", etc.)
    print(f"  Step 9: Selecting matter type: {test_data['matter_type']}...")
    matter_type_dropdown = None
    for entity in MATTER_ENTITY_NAMES:
        try:
            dropdown = form_frame.get_by_role("listbox", name=f"{entity.capitalize()} type")
            if dropdown.count() > 0:
                matter_type_dropdown = dropdown
                break
        except:
            pass
    if not matter_type_dropdown:
        # Fallback: try regex pattern matching any entity + " type"
        entity_pattern = "|".join([e.capitalize() for e in MATTER_ENTITY_NAMES])
        matter_type_dropdown = form_frame.get_by_role("listbox", name=re.compile(rf"({entity_pattern}) type", re.IGNORECASE))
    matter_type_dropdown.click()
    # Wait for dropdown options to appear
    option = form_frame.get_by_role("option", name=test_data["matter_type"])
    option.wait_for(state="visible", timeout=30000)  # Long timeout for slow systems, continues immediately when option appears
    option.click()
    # Wait for dropdown to close (listbox becomes hidden or option is no longer visible)
    page.wait_for_timeout(200)  # Brief settle for dropdown close animation
    
    # Fill Special Instructions
    instructions_field = form_frame.get_by_role("textbox", name="Special instructions/requests")
    instructions_field.click()
    instructions_field.press_sequentially(test_data["special_instructions"], delay=20)
    
    # Fill Private Notes
    notes_field = form_frame.get_by_role("textbox", name="Private notes")
    notes_field.click()
    notes_field.press_sequentially(test_data["private_notes"], delay=20)
    
    # ========== PART 4: Save and Verify ==========
    
    # Step 10: Click Save Button
    print("  Step 10: Clicking Save...")
    save_btn = form_frame.get_by_role("button", name="Save")
    save_btn.click()
    
    # Wait for save to complete - the page will redirect to client page
    page.wait_for_url(re.compile(r"/app/clients/"), timeout=30000)  # Long timeout for slow systems, continues immediately when URL matches
    
    # ========== VERIFICATION ==========
    
    # Verify URL contains matter ID
    expect(page).to_have_url(re.compile(r"/app/clients/[a-z0-9]+"), timeout=30000)  # Long timeout for slow systems, continues immediately when URL matches
    
    # Extract matter ID from URL
    url = page.url
    matter_id_match = re.search(r'/app/clients/([^/]+)', url)
    matter_id = matter_id_match.group(1) if matter_id_match else None
    
    # Wait for page content to load
    page.wait_for_load_state("domcontentloaded")
    
    print(f"  Step 15: Verifying created matter: {test_data['full_name']}...")
    
    # Verify the client name appears in the page title
    # The client detail page has title format: "Property / {Name} | vcita"
    # NOTE: page.get_by_text() doesn't search inside iframes - the client page uses iframes
    # So we verify using the page title instead which contains the client name
    expect(page).to_have_title(re.compile(re.escape(test_data["full_name"])), timeout=30000)  # Long timeout for slow systems, continues immediately when title matches
    
    # Save to context for later tests (especially delete_matter test)
    context["created_matter_name"] = test_data["full_name"]
    context["created_matter_email"] = test_data["email"]
    context["created_matter_id"] = matter_id
    
    print(f"  [OK] Created matter: {test_data['full_name']}")
    print(f"     Email: {test_data['email']}")
    print(f"     Phone: {test_data['phone']}")
    print(f"     Contact Address: {test_data['contact_address']}")
    print(f"     Matter Address: {test_data['matter_address']}")
    print(f"     Matter Type: {test_data['matter_type']}")
    print(f"     Referred By: {test_data['referred_by']}")
    print(f"     Matter ID: {matter_id}")
