# Auto-generated from script.md
# Last updated: 2026-01-21
# Source: tests/clients/create_matter/script.md
# Generated by: Cursor AI exploration with Playwright MCP
# Note: "Matter" is vcita's general entity - called "Property" for Home Services, "Patient" for Healthcare, etc.

import re
import time
import random
from playwright.sync_api import Page, expect

from tests._functions._config import get_base_url
from tests._params import ADD_MATTER_TEXT_REGEX


def generate_test_data() -> dict:
    """Generate comprehensive random test data for matter creation."""
    timestamp = int(time.time())
    first_name = random.choice(["Test", "John", "Jane", "Alex", "Sam"])
    last_name = f"Matter{timestamp}"
    email = f"test_{timestamp}@vcita-test.com"
    # Phone number without special characters (the field strips them)
    phone = f"555{random.randint(1000000, 9999999)}"
    contact_address = f"{random.randint(100, 999)} Test Street, Test City"
    matter_address = f"{random.randint(100, 999)} Property Lane, Property Town"
    matter_type = random.choice(["Residential", "Commercial"])
    help_request = "Looking for regular lawn maintenance and landscaping services"
    special_instructions = f"Please call before arriving. Gate code: {random.randint(1000, 9999)}"
    private_notes = f"VIP customer - Test automation record. Created: {timestamp}"
    referred_by = random.choice(["Google Search", "Facebook", "Friend Referral", "Website"])
    
    return {
        "first_name": first_name,
        "last_name": last_name,
        "full_name": f"{first_name} {last_name}",
        "email": email,
        "phone": phone,
        "contact_address": contact_address,
        "matter_address": matter_address,
        "matter_type": matter_type,
        "help_request": help_request,
        "special_instructions": special_instructions,
        "private_notes": private_notes,
        "referred_by": referred_by,
    }


def test_create_matter(page: Page, context: dict) -> None:
    """
    Test: Create Matter via Quick Actions
    
    Creates a new matter using the Quick Actions menu
    with comprehensive test data including all contact and matter fields.
    
    Note: "Matter" is vcita's general entity - this account uses "Properties" (Home Services vertical)
    
    Saves to context:
    - created_matter_name: The full name of the created matter
    - created_matter_email: The email of the created matter
    - created_matter_id: The ID extracted from the URL (for delete test)
    """
    # Generate test data
    test_data = generate_test_data()
    
    # ========== PART 1: Open the New Matter Form ==========
    # HEALED 2026-01-26: Do NOT use page.goto(base_url + "/app/dashboard"). base_url is www.vcita.com;
    # www.vcita.com/app/dashboard is unavailable (app is on app.vcita.com). Setup leaves us on
    # app.vcita.com/app/dashboard after login. If not on dashboard, navigate via UI only.
    base_url = get_base_url(context)
    print("  Step 1: Ensuring we're on dashboard...")
    if "/app/dashboard" not in page.url:
        dashboard_link = page.get_by_text("Dashboard", exact=True)
        dashboard_link.click()
        page.wait_for_url("**/app/dashboard**", timeout=15000)
    page.wait_for_load_state("domcontentloaded")

    print("  Step 2: Waiting for Quick actions panel...")
    # HEALED 2026-01-22: UI changed - Quick Actions button no longer opens dropdown
    # "Add property" is now directly visible in the Quick actions panel on the right side
    # Must wait for the panel to fully load (async)
    page.get_by_text("Quick actions", exact=True).wait_for(state="visible", timeout=15000)
    # Wait for panel content to fully render (async loading)
    page.wait_for_timeout(3000)
    
    print("  Step 3: Clicking Add matter...")
    # HEALED 2026-01-26: Scope to Quick actions panel. Go up to section that contains both heading and list
    # (.. may be just the heading row on some accounts; .. gets the block that has the action list).
    # Entity list and regex from tests/_params/matter_entities.yaml (single source of truth).
    quick_section = page.get_by_text("Quick actions", exact=True).locator("../..")
    add_matter_text = quick_section.get_by_text(ADD_MATTER_TEXT_REGEX)
    add_matter_text.wait_for(state="visible", timeout=15000)
    
    # Scroll into view and click
    add_matter_text.scroll_into_view_if_needed()
    page.wait_for_timeout(500)
    add_matter_text.click()
    
    print("  Step 4: Waiting for property form...")
    # The form opens in a frame - wait for it to appear
    # Try multiple times to find the form frame (it may take time to load)
    form_frame = None
    max_attempts = 10
    for attempt in range(max_attempts):
        page.wait_for_timeout(500)
        for frame in page.frames:
            try:
                if frame.locator('text=First Name').count() > 0:
                    form_frame = frame
                    break
            except:
                pass
        if form_frame:
            break
        print(f"    Attempt {attempt + 1}/{max_attempts}: Form not found yet...")
    
    if not form_frame:
        # Debug: print all frames
        print("  DEBUG: Available frames:")
        for i, frame in enumerate(page.frames):
            print(f"    [{i}] name='{frame.name}', url='{frame.url[:50]}...'")
        raise Exception("Could not find form frame with 'First Name' field")
    
    print("  Step 5: Waiting for form content (First Name field)...")
    form_frame.locator('text=First Name').wait_for(timeout=15000)
    
    # Step 6: Click "Show more" to expand all contact fields
    # This button must be visible and clicked to access Referred By field
    show_more_btn = form_frame.get_by_role("button", name="Show more")
    show_more_btn.click()
    # Wait for the Referred by field to become visible (indicates expansion complete)
    referred_field_check = form_frame.get_by_role("textbox", name="Referred by")
    referred_field_check.wait_for(state="visible", timeout=5000)
    
    # ========== PART 2: Fill Contact Information ==========
    # Note: Email and Mobile phone fields become comboboxes (autocomplete) when focused
    # Using press_sequentially for realistic user simulation
    
    print("  Step 7: Filling contact information...")
    # Fill First Name (required)
    first_name_field = form_frame.get_by_role("textbox", name="First Name *")
    first_name_field.click()
    first_name_field.press_sequentially(test_data["first_name"], delay=50)
    
    # Fill Last Name
    last_name_field = form_frame.get_by_role("textbox", name="Last Name")
    last_name_field.click()
    last_name_field.press_sequentially(test_data["last_name"], delay=50)
    
    # Fill Email (becomes combobox when focused)
    # Click first, then type - the field transforms to combobox on focus
    email_field = form_frame.get_by_role("textbox", name="Email")
    email_field.click()
    page.wait_for_timeout(100)  # Wait for field transformation
    # Now it's a combobox, type into it
    form_frame.get_by_role("combobox", name="Email").press_sequentially(test_data["email"], delay=30)
    
    # Fill Mobile Phone (becomes combobox when focused)
    phone_field = form_frame.get_by_role("textbox", name="Mobile phone")
    phone_field.click()
    page.wait_for_timeout(100)  # Wait for field transformation
    # Now it's a combobox, type into it
    form_frame.get_by_role("combobox", name="Mobile phone").press_sequentially(test_data["phone"], delay=30)
    
    # Fill Address (contact address) - has Google Places autocomplete
    # Use first one to avoid conflict with Property address
    address_field = form_frame.get_by_label("Address").first
    address_field.click()
    address_field.press_sequentially(test_data["contact_address"], delay=30)
    # Dismiss autocomplete by clicking another field (not Escape - that closes the form!)
    
    # Fill Referred By (only visible after "Show more" click)
    referred_field = form_frame.get_by_role("textbox", name="Referred by")
    referred_field.click()  # This also dismisses the address autocomplete
    referred_field.press_sequentially(test_data["referred_by"], delay=50)
    
    # ========== PART 3: Fill Matter Details ==========
    print("  Step 8: Filling property details...")
    # Fill Matter Address (Property address in this vertical)
    # Has Google Places autocomplete
    matter_address_field = form_frame.get_by_role("textbox", name="Property address")
    matter_address_field.click()
    matter_address_field.press_sequentially(test_data["matter_address"], delay=30)
    
    # Fill Help Request (also dismisses Property address autocomplete)
    help_field = form_frame.get_by_role("textbox", name="How can we help you?")
    help_field.click()  # Dismisses any autocomplete dropdown
    help_field.press_sequentially(test_data["help_request"], delay=20)
    
    # Select Matter Type from dropdown
    print(f"  Step 9: Selecting Property type: {test_data['matter_type']}...")
    matter_type_dropdown = form_frame.get_by_role("listbox", name="Property type")
    matter_type_dropdown.click()
    # Wait for dropdown options to appear
    option = form_frame.get_by_role("option", name=test_data["matter_type"])
    option.wait_for(state="visible", timeout=5000)
    option.click()
    # Wait for dropdown to close (listbox becomes hidden or option is no longer visible)
    page.wait_for_timeout(200)  # Brief settle for dropdown close animation
    
    # Fill Special Instructions
    instructions_field = form_frame.get_by_role("textbox", name="Special instructions/requests")
    instructions_field.click()
    instructions_field.press_sequentially(test_data["special_instructions"], delay=20)
    
    # Fill Private Notes
    notes_field = form_frame.get_by_role("textbox", name="Private notes")
    notes_field.click()
    notes_field.press_sequentially(test_data["private_notes"], delay=20)
    
    # ========== PART 4: Save and Verify ==========
    
    # Step 10: Click Save Button
    print("  Step 10: Clicking Save...")
    save_btn = form_frame.get_by_role("button", name="Save")
    save_btn.click()
    
    # Wait for save to complete - the page will redirect to client page
    page.wait_for_url(re.compile(r"/app/clients/"), timeout=15000)
    
    # ========== VERIFICATION ==========
    
    # Verify URL contains matter ID
    expect(page).to_have_url(re.compile(r"/app/clients/[a-z0-9]+"), timeout=10000)
    
    # Extract matter ID from URL
    url = page.url
    matter_id_match = re.search(r'/app/clients/([^/]+)', url)
    matter_id = matter_id_match.group(1) if matter_id_match else None
    
    # Wait for page content to load
    page.wait_for_load_state("domcontentloaded")
    
    print(f"  Step 15: Verifying created matter: {test_data['full_name']}...")
    
    # Verify the client name appears in the page title
    # The client detail page has title format: "Property / {Name} | vcita"
    # NOTE: page.get_by_text() doesn't search inside iframes - the client page uses iframes
    # So we verify using the page title instead which contains the client name
    expect(page).to_have_title(re.compile(re.escape(test_data["full_name"])), timeout=15000)
    
    # Save to context for later tests (especially delete_matter test)
    context["created_matter_name"] = test_data["full_name"]
    context["created_matter_email"] = test_data["email"]
    context["created_matter_id"] = matter_id
    
    print(f"  [OK] Created matter: {test_data['full_name']}")
    print(f"     Email: {test_data['email']}")
    print(f"     Phone: {test_data['phone']}")
    print(f"     Contact Address: {test_data['contact_address']}")
    print(f"     Matter Address: {test_data['matter_address']}")
    print(f"     Matter Type: {test_data['matter_type']}")
    print(f"     Referred By: {test_data['referred_by']}")
    print(f"     Matter ID: {matter_id}")
