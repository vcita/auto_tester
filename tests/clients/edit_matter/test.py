# Edit Matter Test
# Last updated: 2026-01-21
# Source: tests/clients/edit_matter/steps.md
# Generated by: Cursor AI exploration with Playwright MCP
# Note: "Matter" is vcita's general entity - called "Property" for Home Services, "Patient" for Healthcare, etc.

import re
import time
from playwright.sync_api import Page, expect


def generate_edit_data() -> dict:
    """Generate new values for editing the matter fields."""
    timestamp = int(time.time())
    
    return {
        "help_request": f"EDITED: Need updated property services - {timestamp}",
        "special_instructions": f"EDITED: New gate code is 9999. Updated on {timestamp}",
    }


def test_edit_matter(page: Page, context: dict) -> None:
    """
    Test: Edit Matter Fields
    
    Edits an existing matter by modifying 2 fields and verifying the changes are saved.
    This test runs AFTER create_matter and BEFORE delete_matter.
    
    Reads from context:
    - created_matter_name: The full name of the created matter
    - created_matter_id: The ID of the matter to edit (from URL)
    
    Saves to context:
    - edited_help_request: The new help request value
    - edited_special_instructions: The new special instructions value
    """
    # Verify context has required data from create_matter
    if "created_matter_id" not in context:
        raise ValueError("Context missing 'created_matter_id' - create_matter test must run first")
    
    if "created_matter_name" not in context:
        raise ValueError("Context missing 'created_matter_name' - create_matter test must run first")
    
    matter_id = context["created_matter_id"]
    matter_name = context["created_matter_name"]
    
    print(f"  Editing matter: {matter_name} (ID: {matter_id})")
    
    # Generate new values for editing
    edit_data = generate_edit_data()
    
    # ========== PART 1: Navigate to Matter Detail Page ==========
    
    print("  Step 1: Navigating to matter detail page...")
    # We should already be on the matter detail page after create_matter
    # If not on the correct page, this is an error - previous test should leave us here
    if matter_id not in page.url:
        raise ValueError(f"Expected to be on matter page {matter_id}, but URL is {page.url}. Sequential test context violation.")
    
    # Verify we're on the correct matter page
    expect(page).to_have_url(re.compile(rf"/app/clients/{re.escape(matter_id)}"))
    
    print("  Step 2: Waiting for page to load...")
    # Wait for page title to contain the matter name
    expect(page).to_have_title(re.compile(re.escape(matter_name)), timeout=15000)
    
    # ========== PART 2: Open Edit Property Dialog ==========
    
    print("  Step 3: Opening edit property dialog...")
    # The edit button is in the inner iframe (vue_iframe_layout inside angularjs iframe)
    # Wait for the outer iframe
    angular_iframe = page.locator('iframe[title="angularjs"]')
    angular_iframe.wait_for(state="visible", timeout=15000)
    
    # Get the nested iframe structure
    outer_iframe = page.frame_locator('iframe[title="angularjs"]')
    inner_iframe = outer_iframe.frame_locator('#vue_iframe_layout')
    
    # Wait for content to load - look for the property name button in the header
    inner_iframe.get_by_role("button", name=matter_name).first.wait_for(timeout=15000)
    
    # Find and click the edit button next to the property name
    # The edit button is positioned after the property name button in the matter card header
    # Use getByRole with nth() as this matches the working MCP locator
    edit_button = inner_iframe.get_by_role("button").nth(2)
    edit_button.wait_for(state="visible", timeout=10000)
    edit_button.click()
    
    # Wait for the edit dialog to appear
    # The dialog appears in the outer iframe (angularjs)
    print("  Step 4: Waiting for edit dialog...")
    dialog_title = outer_iframe.locator("text=Edit property info")
    dialog_title.wait_for(state="visible", timeout=10000)
    page.wait_for_timeout(200)  # Brief settle for dialog animation
    
    # ========== PART 3: Modify Fields ==========
    
    print(f"  Step 5: Clearing and filling 'How can we help you?'...")
    # Fill "How can we help you?" field
    help_field = outer_iframe.get_by_role("textbox", name="How can we help you?")
    help_field.click()
    # Clear existing content and fill new value
    help_field.fill("")  # Clear
    help_field.press_sequentially(edit_data["help_request"], delay=20)
    
    print(f"  Step 6: Clearing and filling 'Special instructions/requests'...")
    # Fill "Special instructions/requests" field
    instructions_field = outer_iframe.get_by_role("textbox", name="Special instructions/requests")
    instructions_field.click()
    # Clear existing content and fill new value
    instructions_field.fill("")  # Clear
    instructions_field.press_sequentially(edit_data["special_instructions"], delay=20)
    
    # ========== PART 4: Save Changes ==========
    
    print("  Step 7: Saving changes...")
    # Click Save button
    save_button = outer_iframe.get_by_role("button", name="Save")
    save_button.click()
    
    # Wait for dialog to close by checking the dialog title disappears
    dialog_title.wait_for(state="hidden", timeout=10000)
    
    # Verify dialog is closed by checking the edit button is visible again
    edit_button.wait_for(state="visible", timeout=10000)
    
    # ========== PART 5: Verify Changes ==========
    
    print("  Step 8: Verifying changes were saved...")
    # Open the edit dialog again to verify values
    edit_button.click()
    dialog_title_verify = outer_iframe.locator("text=Edit property info")
    dialog_title_verify.wait_for(state="visible", timeout=10000)
    
    # Verify the help request field has the new value
    help_field_verify = outer_iframe.get_by_role("textbox", name="How can we help you?")
    expect(help_field_verify).to_have_value(edit_data["help_request"], timeout=5000)
    
    # Verify the special instructions field has the new value
    instructions_field_verify = outer_iframe.get_by_role("textbox", name="Special instructions/requests")
    expect(instructions_field_verify).to_have_value(edit_data["special_instructions"], timeout=5000)
    
    # Close the dialog
    cancel_button = outer_iframe.get_by_role("button", name="Cancel")
    cancel_button.click()
    # Wait for dialog to close
    dialog_title_verify.wait_for(state="hidden", timeout=10000)
    
    # Save edited values to context for reference
    context["edited_help_request"] = edit_data["help_request"]
    context["edited_special_instructions"] = edit_data["special_instructions"]
    
    print(f"  [OK] Successfully edited matter: {matter_name}")
    print(f"     New help request: {edit_data['help_request'][:50]}...")
    print(f"     New special instructions: {edit_data['special_instructions'][:50]}...")


# For standalone testing
if __name__ == "__main__":
    from playwright.sync_api import sync_playwright
    import sys
    import os
    
    # Add project root to path
    project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
    sys.path.insert(0, project_root)
    
    # Import login and create_matter functions
    from tests._functions.login.test import fn_login
    from tests.clients.create_matter.test import test_create_matter
    
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=False)
        browser_context = browser.new_context()
        page = browser_context.new_page()
        context = {}
        
        try:
            # Login first
            print("Logging in...")
            fn_login(page, context, username="itzik+autotest@vcita.com", password="vcita123")
            print("Login successful!")
            
            # Create a matter first
            print("\nCreating a matter first...")
            test_create_matter(page, context)
            print("Matter created!")
            
            # Run the edit test
            print("\nEditing the matter...")
            test_edit_matter(page, context)
            print("\n[OK] Test passed!")
            print(f"\nContext after edit:")
            print(f"  - created_matter_name: {context.get('created_matter_name')}")
            print(f"  - created_matter_id: {context.get('created_matter_id')}")
            print(f"  - edited_help_request: {context.get('edited_help_request')}")
            print(f"  - edited_special_instructions: {context.get('edited_special_instructions')}")
            
            # Keep browser open for inspection
            input("\nPress Enter to close browser...")
            
        except Exception as e:
            print(f"\n[FAIL] Test failed: {e}")
            page.screenshot(path="edit_matter_error.png")
            raise
        finally:
            browser.close()
