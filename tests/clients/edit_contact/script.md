# Edit Contact Information - Detailed Script

> **Status**: Generated from exploration
> **Last Updated**: 2026-01-21
> **Generated By**: Cursor AI exploration with Playwright MCP
> **Note**: This test edits CONTACT fields (name, address, referred by) - distinct from edit_matter which edits PROPERTY fields

## Initial State
- URL: Matter detail page (navigated using `created_matter_id` from context)
- Prerequisites: 
  - `created_matter_id` in context (from create_matter test)
  - `created_matter_name` in context (for verification)
  - User is logged in and on the matter detail page

## Actions

### Step 1: Verify Context and Navigate to Matter Detail Page
- **Action**: Check context and navigate if needed
- **Target**: Matter detail page at `/app/clients/{matter_id}`

**LOCATOR DECISION:**

| Option | Pros | Cons |
|--------|------|------|
| Direct URL navigation | Reliable, fast | None |
| Search in properties list | More realistic user flow | Slower, more complex |

HEALED 2026-01-27: Replaced page.goto() with prerequisite check. edit_contact runs after edit_matter, which should leave the browser on the matter detail page. Verify we're on the correct page instead of navigating.

**VERIFIED PLAYWRIGHT CODE**:
```python
# Verify we're already on the correct page (from previous test)
matter_id = context["created_matter_id"]
if matter_id not in page.url:
    raise ValueError(f"Expected to be on matter page {matter_id}, but URL is {page.url}")

# Verify page loaded
page.wait_for_load_state("domcontentloaded")
```

- **How verified**: edit_matter leaves browser on matter detail page; verify state instead of navigating
- **Wait for**: Page load, URL contains matter_id
- **Fallback locators**: None needed for navigation

### Step 2: Wait for Page and Iframes to Load
- **Action**: Wait for nested iframe structure
- **Target**: angularjs iframe and vue_iframe_layout

**VERIFIED PLAYWRIGHT CODE**:
```python
# Wait for outer iframe
page.wait_for_selector('iframe[title="angularjs"]', timeout=15000)
page.wait_for_timeout(2000)  # Extra wait for iframe content

# Get nested iframe structure
outer_iframe = page.frame_locator('iframe[title="angularjs"]')
inner_iframe = outer_iframe.frame_locator('#vue_iframe_layout')
```

- **How verified**: Successfully accessed nested iframes in MCP
- **Wait for**: Iframe selector visible

### Step 3: Open Edit Contact Dialog
- **Action**: Click edit button in contact information section
- **Target**: Edit button (pencil icon) next to contact name

**LOCATOR DECISION:**

| Option | Pros | Cons |
|--------|------|------|
| `inner_iframe.locator('.contact-header > .v-icon.notranslate.edit-button')` | Exact CSS match from MCP | CSS class could change |
| `inner_iframe.get_by_role("button").filter(has_text="")` near contact name | Role-based | Hard to identify specific button |
| `inner_iframe.locator('.edit-button').first` | Simpler | May match wrong edit button |

**CHOSEN**: `inner_iframe.locator('.contact-header > .v-icon.notranslate.edit-button')` - This is the exact selector that worked in MCP. The CSS path is specific to the contact header section, distinguishing it from other edit buttons.

**VERIFIED PLAYWRIGHT CODE**:
```python
# Click edit contact button
edit_contact_button = inner_iframe.locator('.contact-header > .v-icon.notranslate.edit-button')
edit_contact_button.wait_for(state="visible", timeout=10000)
edit_contact_button.click()

# Wait for edit dialog to appear
outer_iframe.locator("text=Edit contact info").wait_for(timeout=10000)
page.wait_for_timeout(500)  # Wait for dialog animation
```

- **How verified**: Clicked in MCP, "Edit contact info" dialog opened successfully
- **Wait for**: Dialog title "Edit contact info" visible
- **Fallback locators**: `.edit-button` within contact section

### Step 4: Edit Last Name Field
- **Action**: Clear and fill new last name value
- **Target**: "Last Name" textbox

**LOCATOR DECISION:**

| Option | Pros | Cons |
|--------|------|------|
| `outer_iframe.get_by_role("textbox", name="Last Name")` | Role + name, semantic | None |
| `outer_iframe.locator('input[name="lastName"]')` | Specific attribute | Less semantic |

**CHOSEN**: `outer_iframe.get_by_role("textbox", name="Last Name")` - Semantic, unique, resilient.

**VERIFIED PLAYWRIGHT CODE**:
```python
# Edit Last Name
last_name_field = outer_iframe.get_by_role("textbox", name="Last Name")
last_name_field.click()
page.keyboard.press("Control+a")  # Select all existing text
last_name_field.press_sequentially(edit_data["last_name"], delay=30)
```

- **How verified**: Field value changed from "Matter1769001836" to "ContactEdit12345" in MCP
- **Value**: Short suffix to avoid ellipsis in table, e.g. "CE{timestamp % 1000000}" (e.g. "CE123456")
- **Fallback locators**: `input[name="lastName"]`

### Step 5: Edit Address Field
- **Action**: Clear and fill new address value
- **Target**: "Address" textbox

**LOCATOR DECISION:**

| Option | Pros | Cons |
|--------|------|------|
| `outer_iframe.get_by_role("textbox", name="Address")` | Role + name, semantic | None |
| `outer_iframe.locator('input[placeholder=""]').nth(N)` | Position-based | Fragile |

**CHOSEN**: `outer_iframe.get_by_role("textbox", name="Address")` - Semantic, unique.

**VERIFIED PLAYWRIGHT CODE**:
```python
# Edit Address - Note: has Google Places autocomplete, clicking another field dismisses it
address_field = outer_iframe.get_by_role("textbox", name="Address")
address_field.click()
page.keyboard.press("Control+a")  # Select all
address_field.press_sequentially(edit_data["address"], delay=30)
```

- **How verified**: Field value changed to "EDITED: 123 Updated Street, New City" in MCP
- **Note**: Address field has Google Places autocomplete.
- **HEALED 2026-01-26**: Do not use Tab (focuses Birthday, opens datepicker, intercepts Referred by). Click dialog title "Edit contact info" to dismiss autocomplete; then click Referred by. No arbitrary waits.
- **Value**: Generated value, e.g., "EDITED: {number} Updated Street, New City"
- **Fallback locators**: Input within address section

### Step 6: Edit Referred By Field
- **Action**: Clear and fill new referred by value
- **Target**: "Referred by" textbox
- **Note**: Before clicking, any open datepicker (e.g. from Birthday) must be dismissed (Escape) or the click will be intercepted.

**LOCATOR DECISION:**

| Option | Pros | Cons |
|--------|------|------|
| `outer_iframe.get_by_role("textbox", name="Referred by")` | Role + name, semantic | None |

**CHOSEN**: `outer_iframe.get_by_role("textbox", name="Referred by")` - Semantic, unique.

**VERIFIED PLAYWRIGHT CODE**:
```python
# Edit Referred by - clicking this also dismisses address autocomplete
referred_field = outer_iframe.get_by_role("textbox", name="Referred by")
referred_field.click()  # This also dismisses address autocomplete dropdown
page.keyboard.press("Control+a")  # Select all
referred_field.press_sequentially(edit_data["referred_by"], delay=30)
```

- **How verified**: Field value changed from "Google Search" to "EDITED: Test Referral Source" in MCP
- **Value**: Generated value, e.g., "EDITED: Test Referral - {timestamp}"
- **Fallback locators**: Input within referred by section

### Step 7: Save Changes
- **Action**: Click Save button
- **Target**: Save button in dialog footer

**LOCATOR DECISION:**

| Option | Pros | Cons |
|--------|------|------|
| `outer_iframe.get_by_role("button", name="Save")` | Role + name, semantic | None |
| `outer_iframe.locator('button:has-text("Save")')` | Text-based | Less semantic |

**CHOSEN**: `outer_iframe.get_by_role("button", name="Save")` - Standard pattern, unique in dialog.

**VERIFIED PLAYWRIGHT CODE**:
```python
# Click Save
save_button = outer_iframe.get_by_role("button", name="Save")
save_button.click()

# Wait for dialog to close and page to update
page.wait_for_timeout(2000)
```

- **How verified**: Dialog closed, page title updated to reflect new name in MCP
- **Wait for**: Dialog closes, page reflects changes
- **Fallback locators**: `button:has-text("Save")`

### Step 8: Verify Changes - Check Page Title
- **Action**: Verify page title contains new contact name
- **Target**: Page title

**VERIFIED PLAYWRIGHT CODE**:
```python
# Verify page title updated with new name
# Page title format: "Property / {First Name} {Last Name} | vcita"
expected_name = f"{first_name} {edit_data['last_name']}"
expect(page).to_have_title(re.compile(re.escape(expected_name)), timeout=10000)
```

- **How verified**: Page title changed from "Property / Alex Matter1769001836" to "Property / Alex ContactEdit12345" in MCP

### Step 9: Verify Changes - Re-open Dialog and Check Fields
- **Action**: Re-open edit dialog and verify all field values
- **Target**: All edited fields

**VERIFIED PLAYWRIGHT CODE**:
```python
# Re-open edit dialog to verify values
edit_contact_button.click()
outer_iframe.locator("text=Edit contact info").wait_for(timeout=10000)
page.wait_for_timeout(500)

# Verify Last Name
expect(outer_iframe.get_by_role("textbox", name="Last Name")).to_have_value(edit_data["last_name"], timeout=5000)

# Verify Address
expect(outer_iframe.get_by_role("textbox", name="Address")).to_have_value(edit_data["address"], timeout=5000)

# Verify Referred by
expect(outer_iframe.get_by_role("textbox", name="Referred by")).to_have_value(edit_data["referred_by"], timeout=5000)

# Close dialog
outer_iframe.get_by_role("button", name="Cancel").click()
page.wait_for_timeout(500)
```

- **How verified**: All three fields showed new values when dialog was re-opened in MCP

## Success Verification
- Page title contains new contact name (First Name + new Last Name)
- Edit dialog shows:
  - New Last Name value
  - New Address value
  - New Referred by value

## Context Updates
After successful edit:
- `edited_last_name`: The new last name value
- `edited_address`: The new address value
- `edited_referred_by`: The new referred by value
- `created_matter_name`: Updated to new full name (original First Name + new Last Name)
