# Phase 3: test.py Rules

## Purpose

The `test.py` file contains **executable Playwright Python code** generated from `script.md`. It should never be manually edited - always regenerate from the script.

This applies to:
- Tests
- Functions  
- Setup/Teardown

## CRITICAL: Debugging Failing Tests

**When a test fails, NEVER guess what the issue is. ALWAYS run it using MCP and observe the UI as a user would.**

- ❌ **WRONG**: Look at error message, guess the fix, change code, run again
- ✅ **RIGHT**: Open MCP browser, execute test steps one by one, observe what actually happens, understand the real problem, then fix

**Key principle**: Trying to fix and run again is NEVER the right way. Check what doesn't work and try to understand by observing the UI first.

## CRITICAL: Use Verified Code Only

**The code in test.py MUST be copied directly from the VERIFIED PLAYWRIGHT CODE blocks in script.md.**

Do NOT:
- "Improve" the verified code with different selectors
- Substitute CSS selectors for role-based locators
- Add semantic selectors that weren't tested
- Guess what locators might work better

The locator decision was already made in Phase 2. Your job in Phase 3 is to copy that verified code, not to re-decide.

## CRITICAL: Prerequisites

**NEVER create test.py without a complete script.md file.**

Before generating test.py, verify:
1. `steps.md` exists and defines the test objectives
2. `script.md` exists with VERIFIED PLAYWRIGHT CODE for every step
3. The verified code was actually tested in MCP

If script.md is missing or incomplete:
- STOP - do not generate test.py
- First create/complete script.md using MCP exploration
- Then generate test.py from the verified code

## Generation Rules

### Source
- Generate ONLY from `script.md`, never directly from `steps.md`
- **Copy VERIFIED PLAYWRIGHT CODE blocks exactly** - do not modify
- Each step in script.md becomes code with comments
- Function calls become imports and function invocations

### Code Structure for Tests

```python
# Auto-generated from script.md
# Last updated: {timestamp}
# Source: tests/{category}/{test_name}/script.md
# DO NOT EDIT MANUALLY - Regenerate from script.md

import re
import time
import pytest
from playwright.sync_api import Page, expect

from tests._functions.login.test import fn_login
from tests._functions.create_client.test import fn_create_client
from src.context import TestContext

class Test{TestName}:
    """
    {Test description from steps.md objective}
    """
    
    def test_{test_name}(self, page: Page, context: TestContext):
        timestamp = int(time.time())
        
        # Step 1: Login
        fn_login(page, context)
        
        # Step 2: Create client
        fn_create_client(page, context, name="Test User", email=f"test-{timestamp}@example.com")
        
        # Step 3: {step description}
        # ... code ...
        
        # Verification
        # ... assertions ...
```

### Code Structure for Functions

```python
# Auto-generated from script.md
# Last updated: {timestamp}
# Source: tests/_functions/{function_name}/script.md
# DO NOT EDIT MANUALLY - Regenerate from script.md

from playwright.sync_api import Page, expect
from src.context import TestContext

def fn_{function_name}(page: Page, context: TestContext, **params):
    """
    {Function description from steps.md objective}
    
    Parameters:
    - name: Client's full name (required)
    - email: Client's email (required)
    - phone: Client's phone (optional)
    
    Saves to context:
    - created_client_id
    """
    name = params.get("name")
    email = params.get("email")
    phone = params.get("phone")
    
    # Step 1: Navigate to CRM
    page.get_by_role("link", name="CRM").click()
    page.wait_for_url("**/crm**")
    
    # Step 2: Click Add Client
    page.get_by_role("button", name="Add Client").click()
    
    # ... more steps ...
    
    # Step 7: Extract and save client ID
    client_id = page.locator(".client-id").text_content()
    context.set("created_client_id", client_id)
```

### Code Structure for Setup/Teardown

```python
# Auto-generated from script.md
# Last updated: {timestamp}
# Source: tests/{category}/_setup/script.md
# DO NOT EDIT MANUALLY - Regenerate from script.md

from playwright.sync_api import Page, expect
from tests._functions.login.test import fn_login
from src.context import TestContext

def setup_{category}(page: Page, context: TestContext):
    """
    Setup for {category} tests
    """
    # Step 1: Login
    fn_login(page, context)
    
    # Step 2: Navigate to section
    # ... code ...
```

### Locator Strategy

**PRIMARY RULE: Use the VERIFIED PLAYWRIGHT CODE from script.md**

1. **ALWAYS copy the exact code from the VERIFIED PLAYWRIGHT CODE block**
   - This code was tested and confirmed working in MCP
   - The locator decision process already evaluated alternatives
   - Do not second-guess or "improve" it

2. **NEVER substitute locators**
   - If script.md has `get_by_role("button").nth(2)`, use EXACTLY that
   - Do not replace it with `.edit-button` because it "looks cleaner"
   - Do not add `data-testid` selectors that weren't tested

3. **If you think a better locator exists:**
   - STOP writing test.py
   - Go to MCP and validate the new locator
   - Update script.md with new VERIFIED PLAYWRIGHT CODE
   - THEN update test.py

4. **Only if script.md lacks verified code** (legacy tests), use this fallback order:
   - `page.get_by_role()` - Most resilient
   - `page.get_by_label()` - For form fields
   - `page.get_by_text()` - For buttons/links with visible text
   - `page.locator()` - CSS selectors from fallback locators

### Text Input Pattern

**ALWAYS use `press_sequentially()` instead of `fill()` for ALL text input:**

```python
# CORRECT - use this pattern
field = page.get_by_label("Phone")
field.click()
page.wait_for_timeout(100)
field.press_sequentially(phone)

# WRONG - never use fill()
page.get_by_label("Phone").fill(phone)
```

**Exception: Clearing fields.** You may use `fill("")` to clear a field before typing; then use `press_sequentially()` for the new value. Add a comment: `# Clear existing content (allowed)`.

**Exception for Rich Text Editors (contenteditable):**

```python
# For contenteditable elements, use keyboard.type()
editable_area = iframe.locator('div[contenteditable="true"]')
editable_area.click()
page.wait_for_timeout(500)
page.keyboard.type("text to type")
```

### CRITICAL: Wait Strategy

**Prefer long waits on meaningful events.** Always wait for something specific: a page to appear, a button, a message, a dropdown menu, a dialog, a list item, a URL change, etc. Use event-based waits (`locator.wait_for(state=...)`, `page.wait_for_url(...)`, etc.) with **long timeouts (30-45 seconds)**. Long waits on meaningful events are preferred—they are robust on slow systems and continue as soon as the condition is met.

**Avoid arbitrary short time waits.** Do not use fixed short delays (e.g. "wait 2 seconds") in place of waiting for a specific UI event. Arbitrary short waits fail when the system is slow and make tests flaky. If the only way to proceed is to wait for "something" to happen, wait for a concrete thing (element visible, dialog closed, URL changed) with a long timeout.

**NEVER use `wait_for_timeout()` alone for action completion.** Every action that changes UI state must wait for a specific element or condition. Use long timeouts on those event-based waits.

**Long timeouts (30-45s) on meaningful events:**
- Element visibility/hidden: `locator.wait_for(state="visible", timeout=30000)` (e.g. page, button, message, dropdown)
- URL navigation: `page.wait_for_url("**/dashboard**", timeout=30000)`
- Iframe loading: `page.wait_for_selector('iframe[title="angularjs"]', timeout=30000)`
- Dialog operations: `dialog.wait_for(state="visible", timeout=30000)` or `state="hidden"`
- List/item appearance: `item.wait_for(state="visible", timeout=30000)`

**For polling loops** (when you can't use a direct event-based wait):
- Use short polling intervals (100-200ms) to check frequently
- Use long overall timeout (30-45s) for the entire polling operation
- Continue immediately when the condition is found
- Example: Poll every 200ms for up to 45 seconds = 225 attempts, but exits immediately when found

#### Wait Patterns

| Action Type | Wait Pattern | Example |
|-------------|--------------|---------|
| Dialog opens | `locator.wait_for(state="visible")` | `dialog.wait_for(state="visible", timeout=30000)` |
| Dialog closes | `locator.wait_for(state="hidden")` | `dialog.wait_for(state="hidden", timeout=30000)` |
| Item created | `locator.wait_for(state="visible")` | `new_row.wait_for(state="visible", timeout=30000)` |
| Item deleted | `locator.wait_for(state="hidden")` | `row.wait_for(state="hidden", timeout=30000)` |
| Navigation | `page.wait_for_url(pattern)` | `page.wait_for_url("**/dashboard**", timeout=30000)` |
| Loading done | `locator.wait_for(state="hidden")` | `spinner.wait_for(state="hidden", timeout=30000)` |

#### Correct Patterns

```python
# CORRECT: Wait for element state after action with long timeout for slow systems
save_btn.click()
dialog.wait_for(state="hidden", timeout=30000)  # Long timeout, continues immediately when dialog closes

# CORRECT: Wait for created item to appear with long timeout
create_btn.click()
new_item = iframe.get_by_role("button").filter(has_text=item_name)
new_item.wait_for(state="visible", timeout=30000)  # Long timeout, continues immediately when item appears

# CORRECT: Navigation with long timeout
page.get_by_text("Dashboard").click()
page.wait_for_url("**/app/dashboard**", timeout=30000)  # Long timeout, continues immediately when URL matches

# CORRECT: Small delay for UI animation AFTER element wait
dialog.wait_for(state="visible", timeout=30000)  # Long timeout for slow systems
page.wait_for_timeout(200)  # Brief settle time for animation (allowed)

# CORRECT: Polling loop with short intervals and long overall timeout
form_frame = None
max_wait_seconds = 45
poll_interval_ms = 200
max_attempts = int(max_wait_seconds * 1000 / poll_interval_ms)  # 225 attempts
for attempt in range(max_attempts):
    form_frame = _find_form_frame()
    if form_frame:
        break  # Continue immediately when found
    page.wait_for_timeout(poll_interval_ms)  # Brief polling interval
```

#### Wrong Patterns

```python
# WRONG: Arbitrary short wait instead of waiting for something specific
save_btn.click()
page.wait_for_timeout(2000)  # Bad - if system is slow, 2s may not be enough; wait for dialog to close instead

# WRONG: Only using expect() without proper wait
create_btn.click()
expect(new_item).to_be_visible()  # May be flaky - use wait_for() first with long timeout
```

#### Acceptable Small Delays

Only use `wait_for_timeout()` for:
- **100-300ms**: Before typing (field transformation/focus)
- **200-500ms**: After element wait, for micro-animation settle

Always pair with an element wait—never use alone for action completion. For "is the action done?" use a long timeout on a meaningful event (e.g. dialog hidden, button visible), not a short fixed delay.

### Handling Virtual Scrolling / Lazy-Loaded Lists (Endless Scroll)

**When searching for items in lists that use virtual scrolling or endless scroll, ALWAYS scroll MULTIPLE TIMES until no more items load, then search.**

Many vcita lists (services, clients, appointments) use endless scroll - items not in viewport are not in the DOM, and scrolling loads more items in batches.

```python
# WRONG - item may exist but not be rendered, and one scroll may not be enough
add_button = iframe.get_by_role('button', name='Add 1 on 1 Appointment')
add_button.scroll_into_view_if_needed()
page.wait_for_timeout(500)
service_btn = iframe.get_by_role('button').filter(has_text=service_name)
service_btn.wait_for(state='visible', timeout=10000)  # May still timeout!

# RIGHT - scroll multiple times until end of list, then search
# Step 1: Wait for list section to load
iframe.get_by_text("My Services").wait_for(state="visible", timeout=10000)

# Step 2: Scroll multiple times until no more items load
max_scrolls = 10
previous_count = 0
for scroll_attempt in range(max_scrolls):
    # Get all service buttons currently visible (use a pattern that matches existing items)
    all_services = iframe.get_by_role("button").filter(has_text="Test Consultation")
    current_count = all_services.count()
    
    if current_count > 0:
        # Scroll the last visible service into view to trigger loading more
        last_service = all_services.nth(current_count - 1)
        last_service.scroll_into_view_if_needed()
        page.wait_for_timeout(1000)  # Wait for new items to load
        
        # Check if new items loaded
        new_count = all_services.count()
        if new_count == previous_count:
            # No new items loaded - we've reached the end
            break
        previous_count = new_count
    else:
        # No services found yet, scroll to "Add" button to trigger initial load
        add_button = iframe.get_by_role('button', name='Add 1 on 1 Appointment')
        add_button.scroll_into_view_if_needed()
        page.wait_for_timeout(1000)

# Step 3: NOW search for the specific item
service_btn = iframe.get_by_role('button').filter(has_text=service_name)
service_btn.wait_for(state='visible', timeout=10000)  # SUCCESS!
```

**When to apply this pattern:**
- **ALWAYS** after creating a new item in a list
- When verifying an item exists in a long list
- When searching for items created in previous tests
- When navigating back to a list page
- **ESPECIALLY** when the list uses endless/infinite scroll (multiple scrolls required)

**Key insight:** Endless scroll lists require MULTIPLE scrolls - each scroll loads a new batch. You must scroll repeatedly until the count stops increasing, THEN search.

See `build.mdc` for detailed explanation of endless scroll behavior.

### Context Operations

```python
# Saving to context
client_id = page.locator(".client-id").text_content()
context.set("created_client_id", client_id)

# Reading from context
meeting_id = context.get("created_meeting_id")
page.goto(f"{base_url}/meetings/{meeting_id}")
```

### Conditional Steps

```python
# Step 5: Fill Phone (if provided)
if phone:
    phone_field = page.get_by_label("Phone")
    phone_field.click()
    page.wait_for_timeout(100)
    phone_field.press_sequentially(phone)
```

### No Retries for Actions

**Do not retry user actions.** Wait for a condition that indicates the system is ready, then perform the action once. No loops that retry clicks, fills, or navigation (e.g. "click Add matter; if form not found, click again"). If the action fails, the test fails.

### No Fallbacks for Detection (Single Detection Per Step)

**Each step must have one clear way to detect that something happened or that the UI is ready for the next action.** Do not add fallback locators or try/except chains that try a second (or third) way to detect the same condition.

- **Rule**: For each step, choose **one** object or condition to wait on (e.g. one button visible, one heading, one URL). If that condition is not found, the test should fail—do not "fall back" to waiting on a different element or using a different locator in the same step.
- **Do NOT**: Use try/except to try locator A, then on failure try locator B for the same "ready" condition. Do not document "Fallback: try get_by_text if get_by_role fails."
- **If the primary wait is unreliable**: Re-explore in MCP, pick a **different** single object/condition that reliably indicates readiness, and use that instead—still one condition per step.

See `project.mdc` § Single Detection Per Step (No Fallbacks).

### Timeout Means Failure

**If a wait times out, the test must fail and stop.** Never catch a timeout and continue the test as if the step succeeded.

- **Rule**: When waiting for something that should have happened (element visible, URL changed, dialog closed, etc.), use event-based waits with a long timeout. If the timeout is reached, the wait raises; **do not** catch that exception and continue. The test must fail so the test sequence stops.
- **Do NOT**: Use try/except around a wait and in the except block continue to the next step, or use a "fallback" action (e.g. time out waiting for the Schedule button then proceed to fill the form anyway).

See `project.mdc` § Timeout Means Failure.

### Error Handling

- Don't add try/except blocks - let failures surface
- Use Playwright's built-in waiting (auto-wait)
- Add explicit waits only when script.md specifies them

## CRITICAL: No Standalone Test Blocks

**NEVER add `if __name__ == "__main__":` blocks to test files.**

Tests MUST be run through the runner:
```bash
python main.py run --category <category_name>
```

The runner handles:
- Captcha bypass (custom user-agent)
- Proper timeouts
- Video recording for debugging
- Screenshots on failure
- Browser lifecycle management
- Context sharing between tests

**Category is the atomic test unit** - you cannot run individual tests. This ensures:
1. Setup/teardown always run
2. Tests run in the correct order
3. Configuration is consistent
4. No duplicate code to maintain

### Assertions and Success Verification

**CRITICAL: Verify actual data, NEVER rely on toast messages or confirmation dialogs.**

**CRITICAL: Confirm the action was actually performed.** Every test that changes state (create, update, delete, cancel, add, remove) must include assertions that prove the outcome, not only that the UI flow completed (e.g. dialog closed or URL changed). Examples: after delete, assert the item is gone (e.g. row count 0 or row hidden); after cancel, assert the entity is marked CANCELLED/removed where the app displays status (e.g. Event List row contains "CANCELLED"); after create, assert the new item appears in the list or detail. Copy these verification steps from script.md VERIFIED PLAYWRIGHT CODE.

Use Playwright's `expect()` for assertions on **actual data**:

```python
# CORRECT - verify actual data exists
expect(page.get_by_role("row", name=client_name)).to_be_visible()  # Item in list
expect(page).to_have_url(re.compile(r"/app/clients/[a-z0-9]+"))  # URL has ID
expect(iframe.get_by_role("menuitem").filter(has_text=client_name)).to_be_visible()  # Calendar event

# CORRECT - verify deleted item is gone
expect(page.get_by_role("row", name=deleted_name)).to_have_count(0)

# WRONG - NEVER rely on toast/confirmation messages
expect(page.get_by_text("Success!")).to_be_visible()  # Forbidden
expect(page.get_by_text("Deleted successfully")).to_be_visible()  # Forbidden
expect(page.get_by_text("Appointment scheduled")).to_be_visible()  # Forbidden
```

**Forbidden verification patterns:**
- Toast messages ("Success", "Created", "Deleted", "Saved")
- Snackbar notifications
- Alert dialogs confirming action
- Any auto-dismissing UI element

**Required verification patterns:**
- Item appears in list/grid/calendar
- URL contains new item's ID
- Page title shows item name
- Form fields show saved values
- Search results include the item
- Count increased/decreased

## When to Regenerate

- `script.md` is updated (new VERIFIED PLAYWRIGHT CODE)
- Self-healing finds a working selector (must update script.md first!)
- Never manually edit - always regenerate

## Self-Healing Updates

When self-healing fixes a selector:
1. **First**: Update `script.md` with new VERIFIED PLAYWRIGHT CODE
2. **Then**: Regenerate `test.py` from the updated script
3. Log the change in `changelog.md`

**IMPORTANT**: Never update test.py without also updating script.md. The script.md is the source of truth.

## File Header

Always include this header:
```python
# Auto-generated from script.md
# Last updated: YYYY-MM-DD HH:MM:SS
# Source: tests/{path}/script.md
# DO NOT EDIT MANUALLY - This file is regenerated from script.md
```

## Cascade Effect

`test.py` is the end of the cascade - changes here don't flow upward. However, if self-healing discovers that the UI flow has fundamentally changed, it should trigger updates to `script.md` and potentially `steps.md`.

## Execution Order

When running a category:
1. Run `_setup/test.py` (if exists)
2. Run tests in order from `_category.yaml`
3. On failure: stop, attempt self-heal, retry
4. Run `_teardown/test.py` (if exists, even on failure)
