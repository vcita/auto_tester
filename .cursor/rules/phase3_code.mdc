# Phase 3: test.py Rules

## Purpose

The `test.py` file contains **executable Playwright Python code** generated from `script.md`. It should never be manually edited - always regenerate from the script.

This applies to:
- Tests
- Functions  
- Setup/Teardown

## CRITICAL: Debugging Failing Tests

**When a test fails, NEVER guess what the issue is. ALWAYS run it using MCP and observe the UI as a user would.**

- ❌ **WRONG**: Look at error message, guess the fix, change code, run again
- ✅ **RIGHT**: Open MCP browser, execute test steps one by one, observe what actually happens, understand the real problem, then fix

**Key principle**: Trying to fix and run again is NEVER the right way. Check what doesn't work and try to understand by observing the UI first.

## CRITICAL: Use Verified Code Only

**The code in test.py MUST be copied directly from the VERIFIED PLAYWRIGHT CODE blocks in script.md.**

Do NOT:
- "Improve" the verified code with different selectors
- Substitute CSS selectors for role-based locators
- Add semantic selectors that weren't tested
- Guess what locators might work better

The locator decision was already made in Phase 2. Your job in Phase 3 is to copy that verified code, not to re-decide.

## CRITICAL: Prerequisites

**NEVER create test.py without a complete script.md file.**

Before generating test.py, verify:
1. `steps.md` exists and defines the test objectives
2. `script.md` exists with VERIFIED PLAYWRIGHT CODE for every step
3. The verified code was actually tested in MCP

If script.md is missing or incomplete:
- STOP - do not generate test.py
- First create/complete script.md using MCP exploration
- Then generate test.py from the verified code

## Generation Rules

### Source
- Generate ONLY from `script.md`, never directly from `steps.md`
- **Copy VERIFIED PLAYWRIGHT CODE blocks exactly** - do not modify
- Each step in script.md becomes code with comments
- Function calls become imports and function invocations

### Code Structure for Tests

```python
# Auto-generated from script.md
# Last updated: {timestamp}
# Source: tests/{category}/{test_name}/script.md
# DO NOT EDIT MANUALLY - Regenerate from script.md

import re
import time
import pytest
from playwright.sync_api import Page, expect

from tests._functions.login.test import fn_login
from tests._functions.create_client.test import fn_create_client
from src.context import TestContext

class Test{TestName}:
    """
    {Test description from steps.md objective}
    """
    
    def test_{test_name}(self, page: Page, context: TestContext):
        timestamp = int(time.time())
        
        # Step 1: Login
        fn_login(page, context)
        
        # Step 2: Create client
        fn_create_client(page, context, name="Test User", email=f"test-{timestamp}@example.com")
        
        # Step 3: {step description}
        # ... code ...
        
        # Verification
        # ... assertions ...
```

### Code Structure for Functions

```python
# Auto-generated from script.md
# Last updated: {timestamp}
# Source: tests/_functions/{function_name}/script.md
# DO NOT EDIT MANUALLY - Regenerate from script.md

from playwright.sync_api import Page, expect
from src.context import TestContext

def fn_{function_name}(page: Page, context: TestContext, **params):
    """
    {Function description from steps.md objective}
    
    Parameters:
    - name: Client's full name (required)
    - email: Client's email (required)
    - phone: Client's phone (optional)
    
    Saves to context:
    - created_client_id
    """
    name = params.get("name")
    email = params.get("email")
    phone = params.get("phone")
    
    # Step 1: Navigate to CRM
    page.get_by_role("link", name="CRM").click()
    page.wait_for_url("**/crm**")
    
    # Step 2: Click Add Client
    page.get_by_role("button", name="Add Client").click()
    
    # ... more steps ...
    
    # Step 7: Extract and save client ID
    client_id = page.locator(".client-id").text_content()
    context.set("created_client_id", client_id)
```

### Code Structure for Setup/Teardown

```python
# Auto-generated from script.md
# Last updated: {timestamp}
# Source: tests/{category}/_setup/script.md
# DO NOT EDIT MANUALLY - Regenerate from script.md

from playwright.sync_api import Page, expect
from tests._functions.login.test import fn_login
from src.context import TestContext

def setup_{category}(page: Page, context: TestContext):
    """
    Setup for {category} tests
    """
    # Step 1: Login
    fn_login(page, context)
    
    # Step 2: Navigate to section
    # ... code ...
```

### Locator Strategy

**PRIMARY RULE: Use the VERIFIED PLAYWRIGHT CODE from script.md**

1. **ALWAYS copy the exact code from the VERIFIED PLAYWRIGHT CODE block**
   - This code was tested and confirmed working in MCP
   - The locator decision process already evaluated alternatives
   - Do not second-guess or "improve" it

2. **NEVER substitute locators**
   - If script.md has `get_by_role("button").nth(2)`, use EXACTLY that
   - Do not replace it with `.edit-button` because it "looks cleaner"
   - Do not add `data-testid` selectors that weren't tested

3. **If you think a better locator exists:**
   - STOP writing test.py
   - Go to MCP and validate the new locator
   - Update script.md with new VERIFIED PLAYWRIGHT CODE
   - THEN update test.py

4. **Only if script.md lacks verified code** (legacy tests), use this fallback order:
   - `page.get_by_role()` - Most resilient
   - `page.get_by_label()` - For form fields
   - `page.get_by_text()` - For buttons/links with visible text
   - `page.locator()` - CSS selectors from fallback locators

### Text Input Pattern

**ALWAYS use `press_sequentially()` instead of `fill()` for ALL text input:**

```python
# CORRECT - use this pattern
field = page.get_by_label("Phone")
field.click()
page.wait_for_timeout(100)
field.press_sequentially(phone)

# WRONG - never use fill()
page.get_by_label("Phone").fill(phone)
```

**Exception for Rich Text Editors (contenteditable):**

```python
# For contenteditable elements, use keyboard.type()
editable_area = iframe.locator('div[contenteditable="true"]')
editable_area.click()
page.wait_for_timeout(500)
page.keyboard.type("text to type")
```

### CRITICAL: Wait Strategy

**No arbitrary time waits.** Always wait for a concrete event (element state, URL, list loaded, etc.) with a timeout. Never assume "wait X seconds" is enough—use `locator.wait_for(state=...)`, `page.wait_for_url(...)`, or similar so the test proceeds as soon as the condition is met (or fails after the timeout).

**NEVER use `wait_for_timeout()` alone.** Every action that changes UI state must wait for a specific element.

#### Wait Patterns

| Action Type | Wait Pattern | Example |
|-------------|--------------|---------|
| Dialog opens | `locator.wait_for(state="visible")` | `dialog.wait_for(state="visible", timeout=10000)` |
| Dialog closes | `locator.wait_for(state="hidden")` | `dialog.wait_for(state="hidden", timeout=10000)` |
| Item created | `locator.wait_for(state="visible")` | `new_row.wait_for(state="visible", timeout=10000)` |
| Item deleted | `locator.wait_for(state="hidden")` | `row.wait_for(state="hidden", timeout=10000)` |
| Navigation | `page.wait_for_url(pattern)` | `page.wait_for_url("**/dashboard**")` |
| Loading done | `locator.wait_for(state="hidden")` | `spinner.wait_for(state="hidden", timeout=15000)` |

#### Correct Patterns

```python
# CORRECT: Wait for element state after action
save_btn.click()
dialog.wait_for(state="hidden", timeout=10000)  # Wait for dialog to close

# CORRECT: Wait for created item to appear
create_btn.click()
new_item = iframe.get_by_role("button").filter(has_text=item_name)
new_item.wait_for(state="visible", timeout=10000)

# CORRECT: Small delay for UI animation AFTER element wait
dialog.wait_for(state="visible", timeout=10000)
page.wait_for_timeout(200)  # Brief settle time for animation
```

#### Wrong Patterns

```python
# WRONG: Fixed delay without element verification
save_btn.click()
page.wait_for_timeout(2000)  # Bad - how do we know it's done?

# WRONG: Only using expect() without proper wait
create_btn.click()
expect(new_item).to_be_visible()  # May be flaky - use wait_for() first
```

#### Acceptable Small Delays

Only use `wait_for_timeout()` for:
- **100-300ms**: Before typing (field transformation/focus)
- **200-500ms**: After element wait, for micro-animation settle

Always pair with an element wait - never use alone for action completion.

### Handling Virtual Scrolling / Lazy-Loaded Lists (Endless Scroll)

**When searching for items in lists that use virtual scrolling or endless scroll, ALWAYS scroll MULTIPLE TIMES until no more items load, then search.**

Many vcita lists (services, clients, appointments) use endless scroll - items not in viewport are not in the DOM, and scrolling loads more items in batches.

```python
# WRONG - item may exist but not be rendered, and one scroll may not be enough
add_button = iframe.get_by_role('button', name='Add 1 on 1 Appointment')
add_button.scroll_into_view_if_needed()
page.wait_for_timeout(500)
service_btn = iframe.get_by_role('button').filter(has_text=service_name)
service_btn.wait_for(state='visible', timeout=10000)  # May still timeout!

# RIGHT - scroll multiple times until end of list, then search
# Step 1: Wait for list section to load
iframe.get_by_text("My Services").wait_for(state="visible", timeout=10000)

# Step 2: Scroll multiple times until no more items load
max_scrolls = 10
previous_count = 0
for scroll_attempt in range(max_scrolls):
    # Get all service buttons currently visible (use a pattern that matches existing items)
    all_services = iframe.get_by_role("button").filter(has_text="Test Consultation")
    current_count = all_services.count()
    
    if current_count > 0:
        # Scroll the last visible service into view to trigger loading more
        last_service = all_services.nth(current_count - 1)
        last_service.scroll_into_view_if_needed()
        page.wait_for_timeout(1000)  # Wait for new items to load
        
        # Check if new items loaded
        new_count = all_services.count()
        if new_count == previous_count:
            # No new items loaded - we've reached the end
            break
        previous_count = new_count
    else:
        # No services found yet, scroll to "Add" button to trigger initial load
        add_button = iframe.get_by_role('button', name='Add 1 on 1 Appointment')
        add_button.scroll_into_view_if_needed()
        page.wait_for_timeout(1000)

# Step 3: NOW search for the specific item
service_btn = iframe.get_by_role('button').filter(has_text=service_name)
service_btn.wait_for(state='visible', timeout=10000)  # SUCCESS!
```

**When to apply this pattern:**
- **ALWAYS** after creating a new item in a list
- When verifying an item exists in a long list
- When searching for items created in previous tests
- When navigating back to a list page
- **ESPECIALLY** when the list uses endless/infinite scroll (multiple scrolls required)

**Key insight:** Endless scroll lists require MULTIPLE scrolls - each scroll loads a new batch. You must scroll repeatedly until the count stops increasing, THEN search.

See `build.mdc` for detailed explanation of endless scroll behavior.

### Context Operations

```python
# Saving to context
client_id = page.locator(".client-id").text_content()
context.set("created_client_id", client_id)

# Reading from context
meeting_id = context.get("created_meeting_id")
page.goto(f"{base_url}/meetings/{meeting_id}")
```

### Conditional Steps

```python
# Step 5: Fill Phone (if provided)
if phone:
    phone_field = page.get_by_label("Phone")
    phone_field.click()
    page.wait_for_timeout(100)
    phone_field.press_sequentially(phone)
```

### Error Handling

- Don't add try/except blocks - let failures surface
- Use Playwright's built-in waiting (auto-wait)
- Add explicit waits only when script.md specifies them

## CRITICAL: No Standalone Test Blocks

**NEVER add `if __name__ == "__main__":` blocks to test files.**

Tests MUST be run through the runner:
```bash
python main.py run --category <category_name>
```

The runner handles:
- Captcha bypass (custom user-agent)
- Proper timeouts
- Video recording for debugging
- Screenshots on failure
- Browser lifecycle management
- Context sharing between tests

**Category is the atomic test unit** - you cannot run individual tests. This ensures:
1. Setup/teardown always run
2. Tests run in the correct order
3. Configuration is consistent
4. No duplicate code to maintain

### Assertions and Success Verification

**CRITICAL: Verify actual data, NEVER rely on toast messages or confirmation dialogs.**

**CRITICAL: Confirm the action was actually performed.** Every test that changes state (create, update, delete, cancel, add, remove) must include assertions that prove the outcome, not only that the UI flow completed (e.g. dialog closed or URL changed). Examples: after delete, assert the item is gone (e.g. row count 0 or row hidden); after cancel, assert the entity is marked CANCELLED/removed where the app displays status (e.g. Event List row contains "CANCELLED"); after create, assert the new item appears in the list or detail. Copy these verification steps from script.md VERIFIED PLAYWRIGHT CODE.

Use Playwright's `expect()` for assertions on **actual data**:

```python
# CORRECT - verify actual data exists
expect(page.get_by_role("row", name=client_name)).to_be_visible()  # Item in list
expect(page).to_have_url(re.compile(r"/app/clients/[a-z0-9]+"))  # URL has ID
expect(iframe.get_by_role("menuitem").filter(has_text=client_name)).to_be_visible()  # Calendar event

# CORRECT - verify deleted item is gone
expect(page.get_by_role("row", name=deleted_name)).to_have_count(0)

# WRONG - NEVER rely on toast/confirmation messages
expect(page.get_by_text("Success!")).to_be_visible()  # Forbidden
expect(page.get_by_text("Deleted successfully")).to_be_visible()  # Forbidden
expect(page.get_by_text("Appointment scheduled")).to_be_visible()  # Forbidden
```

**Forbidden verification patterns:**
- Toast messages ("Success", "Created", "Deleted", "Saved")
- Snackbar notifications
- Alert dialogs confirming action
- Any auto-dismissing UI element

**Required verification patterns:**
- Item appears in list/grid/calendar
- URL contains new item's ID
- Page title shows item name
- Form fields show saved values
- Search results include the item
- Count increased/decreased

## When to Regenerate

- `script.md` is updated (new VERIFIED PLAYWRIGHT CODE)
- Self-healing finds a working selector (must update script.md first!)
- Never manually edit - always regenerate

## Self-Healing Updates

When self-healing fixes a selector:
1. **First**: Update `script.md` with new VERIFIED PLAYWRIGHT CODE
2. **Then**: Regenerate `test.py` from the updated script
3. Log the change in `changelog.md`

**IMPORTANT**: Never update test.py without also updating script.md. The script.md is the source of truth.

## File Header

Always include this header:
```python
# Auto-generated from script.md
# Last updated: YYYY-MM-DD HH:MM:SS
# Source: tests/{path}/script.md
# DO NOT EDIT MANUALLY - This file is regenerated from script.md
```

## Cascade Effect

`test.py` is the end of the cascade - changes here don't flow upward. However, if self-healing discovers that the UI flow has fundamentally changed, it should trigger updates to `script.md` and potentially `steps.md`.

## Execution Order

When running a category:
1. Run `_setup/test.py` (if exists)
2. Run tests in order from `_category.yaml`
3. On failure: stop, attempt self-heal, retry
4. Run `_teardown/test.py` (if exists, even on failure)
