# Phase 2: script.md Rules

## Purpose

The `script.md` file is a **detailed action script** that bridges human intent (steps.md) and executable code (test.py). It contains precise, actionable instructions discovered through browser exploration, including **verified Playwright code** that was tested in MCP.

This applies to:
- Tests
- Functions
- Setup/Teardown

## CRITICAL: Verified Code Requirement

Every action step MUST include **VERIFIED PLAYWRIGHT CODE** - the exact code that was tested and confirmed working in MCP. This is not optional. The code in test.py will be copied directly from this verified code.

## Writing Guidelines

### Content Focus
- Specific actions with exact targets
- **Locator decision process** (evaluate options before choosing)
- **Verified Playwright code** (tested in MCP)
- Wait conditions after actions
- Verification checkpoints
- Fallback locators for self-healing

### Structure for Each Step

Each action MUST include:
- **Action**: What to do (Click, Type, Wait, Scroll, Call, etc.)
- **Target**: What element to interact with
- **LOCATOR DECISION**: Table of options evaluated with pros/cons
- **CHOSEN LOCATOR**: Which option was selected and why
- **VERIFIED PLAYWRIGHT CODE**: The exact code tested in MCP (REQUIRED)
- **How verified**: What behavior confirmed it worked
- **Value** (if applicable): Data to enter
- **Wait for**: What to expect after the action
- **Fallback locators**: Alternative selectors for self-healing

### Locator Decision Process

Before documenting a step, you MUST evaluate locator options:

1. **Identify all possible locators** for the element
2. **Evaluate pros/cons** of each option:
   - Uniqueness: Does it match exactly one element?
   - Resilience: Will it survive UI changes?
   - Readability: Is it clear what element this targets?
3. **Choose the best option** based on priority:
   - Unique role + name (most resilient)
   - Unique label/text (readable, fairly resilient)
   - Unique test-id/data attribute (if available)
   - CSS class (if semantic and unlikely to change)
   - Position-based (last resort, document why)
4. **Validate in MCP** before documenting
5. **Document the decision** including rationale

## CRITICAL: Text Input Method

**ALWAYS use `press_sequentially()` instead of `fill()` for typing text.**

Standard pattern for ALL text input:
```python
field.click()  # Focus the field first
page.wait_for_timeout(100)  # Brief wait for any transformations
field.press_sequentially("value to type")  # Type character by character
```

Why:
- Better simulation of real users
- Triggers all input events (keydown/keyup)
- Works with autocomplete/combobox fields
- More reliable across different field types

### Exception: Rich Text Editors (contenteditable)

For rich text editors using `contenteditable="true"` (like TinyMCE, Quill, etc.), use `page.keyboard.type()`:

```python
# Rich text editor pattern
editable_area = iframe.locator('div[contenteditable="true"]')
editable_area.click()  # Focus the editor
page.wait_for_timeout(500)
page.keyboard.type("text to type")  # Use keyboard.type for contenteditable
```

This is because `press_sequentially()` doesn't work with contenteditable elements.

## Example Step (NEW FORMAT)

```markdown
### Step 3: Click Edit Button

- **Action**: Click
- **Target**: Edit button (pencil icon) next to property name

**LOCATOR DECISION:**

| Option | Pros | Cons |
|--------|------|------|
| `get_by_role("button", name="Edit")` | Semantic, accessible | Button has no accessible name |
| `locator(".edit-button")` | Clear intent | Class might not exist or change |
| `get_by_role("button").nth(2)` | Works reliably | Fragile if button order changes |
| `locator("[data-action='edit']")` | Unique identifier | No data attribute exists |

**CHOSEN**: `get_by_role("button").nth(2)` - No unique identifier available; this is the third button in the header container.

**VERIFIED PLAYWRIGHT CODE**:
```python
outer_iframe = page.frame_locator('iframe[title="angularjs"]')
inner_iframe = outer_iframe.frame_locator('#vue_iframe_layout')
edit_button = inner_iframe.get_by_role("button").nth(2)
edit_button.click()
```

- **How verified**: Clicked in MCP, "Edit property info" dialog opened successfully
- **Wait for**: Dialog with "Edit property info" title appears
- **Fallback locators** (for self-healing):
  - `locator(".matter-card-title").locator("button").nth(1)`
  - `locator("button").filter(has=locator("svg"))`
```

## Simple Step Example

For straightforward elements with clear identifiers:

```markdown
### Step 5: Click Save Button

- **Action**: Click
- **Target**: Save button in dialog

**LOCATOR DECISION:**

| Option | Pros | Cons |
|--------|------|------|
| `get_by_role("button", name="Save")` | Unique, semantic | None |
| `locator(".btn-save")` | Clear class | Less resilient |

**CHOSEN**: `get_by_role("button", name="Save")` - Unique and semantic.

**VERIFIED PLAYWRIGHT CODE**:
```python
save_button = outer_iframe.get_by_role("button", name="Save")
save_button.click()
```

- **How verified**: Clicked in MCP, dialog closed, changes saved
- **Wait for**: Dialog closes, returns to detail page
- **Fallback locators**: `locator(".dialog-actions button:has-text('Save')")`
```

## Function Calls in Script

When a step calls a function, no locator decision is needed:

```markdown
### Step 2: Create test client
- **Action**: Call function
- **Function**: create_client
- **Parameters**:
  - name: "Test Customer"
  - email: "test-{timestamp}@example.com"
- **Expected return**: created_client_id saved to context
```

## Context Operations

### Saving to Context
```markdown
### Step 5: Save meeting ID
- **Action**: Extract and save
- **Target**: Meeting ID element

**LOCATOR DECISION:**

| Option | Pros | Cons |
|--------|------|------|
| `locator(".meeting-id")` | Semantic class | Might not be unique |
| `locator("[data-testid='meeting-id']")` | Test ID, very stable | Might not exist |

**CHOSEN**: `locator("[data-testid='meeting-id']")` - Test IDs are most stable.

**VERIFIED PLAYWRIGHT CODE**:
```python
meeting_id_element = page.locator("[data-testid='meeting-id']")
meeting_id = meeting_id_element.text_content()
context["created_meeting_id"] = meeting_id
```

- **How verified**: Extracted text in MCP, confirmed format matches MTG-[0-9]+
- **Save to context**: created_meeting_id
- **Pattern**: Extract text matching `MTG-[0-9]+`
- **Fallback locators**: `.meeting-id`, `[data-meeting-id]`
```

### Reading from Context
```markdown
### Step 1: Open the meeting
- **Action**: Navigate
- **URL**: "{base_url}/meetings/{context.created_meeting_id}"
- **No locator decision needed** (navigation uses URL, not element)
```

## Placeholders

Use these placeholders for dynamic values:
- `{timestamp}` - Unix timestamp for unique values
- `{base_url}` - From config.yaml
- `{random_string}` - Random alphanumeric string
- `{context.key}` - Value from shared context
- `{param_name}` - Function parameter value

## Function Script Example (NEW FORMAT)

**`tests/_functions/create_client/script.md`:**
```markdown
# Create Client - Detailed Script

## Parameters
- name (required)
- email (required)
- phone (optional)

## Initial State
- URL: Any page (will navigate to CRM)
- User must be logged in

## Actions

### Step 1: Navigate to CRM
- **Action**: Click
- **Target**: CRM menu item

**LOCATOR DECISION:**

| Option | Pros | Cons |
|--------|------|------|
| `get_by_role("link", name="CRM")` | Semantic, accessible | None |
| `locator("[data-nav='crm']")` | Data attribute | Might not exist |

**CHOSEN**: `get_by_role("link", name="CRM")` - Unique and semantic.

**VERIFIED PLAYWRIGHT CODE**:
```python
page.get_by_role("link", name="CRM").click()
page.wait_for_url("**/crm**")
```

- **How verified**: Clicked in MCP, navigated to CRM page
- **Wait for**: URL contains "/crm"
- **Fallback locators**: `[data-nav="crm"]`, `.nav-item:has-text("CRM")`

### Step 2: Click Add Client
- **Action**: Click
- **Target**: Add client button

**LOCATOR DECISION:**

| Option | Pros | Cons |
|--------|------|------|
| `get_by_role("button", name="Add Client")` | Semantic | None |
| `locator(".btn-add-client")` | Class-based | Less resilient |

**CHOSEN**: `get_by_role("button", name="Add Client")` - Unique button with clear name.

**VERIFIED PLAYWRIGHT CODE**:
```python
page.get_by_role("button", name="Add Client").click()
```

- **How verified**: Clicked in MCP, client form appeared
- **Wait for**: Client form dialog/page appears
- **Fallback locators**: `.btn-add-client`

### Step 3: Fill Name
- **Action**: Type
- **Target**: Name field
- **Value**: "{name}"

**LOCATOR DECISION:**

| Option | Pros | Cons |
|--------|------|------|
| `get_by_label("Name")` | Accessible | Might match multiple |
| `get_by_role("textbox", name="Name")` | More specific | None |

**CHOSEN**: `get_by_role("textbox", name="Name")` - Specific role + name.

**VERIFIED PLAYWRIGHT CODE**:
```python
name_field = page.get_by_role("textbox", name="Name")
name_field.click()
page.wait_for_timeout(100)
name_field.press_sequentially(name)
```

- **How verified**: Typed in MCP, value appeared in field character by character
- **Fallback locators**: `get_by_label("Name")`, `input[name="client_name"]`

### Step 4-7: (similar format with LOCATOR DECISION and VERIFIED PLAYWRIGHT CODE)
...

## Success Verification
- Success message is visible
- Client ID is captured
```

## CRITICAL: Outcome Verification for State-Changing Actions

**Every test that performs a state-changing action (create, update, delete, cancel, add, remove) MUST include a final verification step with VERIFIED PLAYWRIGHT CODE that confirms the action actually took effect.**

- **Do not rely only on**: dialog closes, navigation, or toast messages.
- **Do include**: Assertions that check the real outcome in the UI:
  - **Create**: New item visible in list/detail (e.g. row with name, or URL with new ID).
  - **Delete/Remove**: Item gone from list or row shows removed/deleted status (e.g. `row.wait_for(state="hidden")` or assert row text contains "REMOVED"/"CANCELLED").
  - **Cancel**: Status is cancelled where the app shows it (e.g. Event List row contains "CANCELLED").
  - **Update**: Changed data visible on the page (e.g. get_by_text(updated_value) visible).
- Document this as a dedicated step (e.g. "Step N: Verify event is cancelled") with **VERIFIED PLAYWRIGHT CODE** that performs the assertion (e.g. open Event List, find row by context key, assert text contains "CANCELLED"; or find row and expect count 0 after delete).
- **Success Verification** in script.md should list these outcome checks explicitly.

## When to Update script.md

- UI elements change (new selectors discovered)
- New intermediate steps are needed
- Wait conditions need adjustment
- After successful re-exploration
- **When self-healing finds a better locator** (update VERIFIED PLAYWRIGHT CODE)

## CRITICAL: Wait Strategy

**No arbitrary time waits.** Always wait for a concrete event (element visible/hidden, URL, list loaded, etc.) with a timeout. Never assume "wait X seconds" is enough.

**NEVER use `wait_for_timeout()` alone.** Every action that changes UI state must wait for a specific element or condition.

### During MCP Exploration

For every action step, you MUST identify:
1. **What element indicates the action completed?** (dialog appeared, item in list, button enabled, etc.)
2. **Document the wait condition** in the script alongside the action

### Wait Patterns by Action Type

| Action Type | Wait Pattern | Example |
|-------------|--------------|---------|
| Dialog opens | `dialog.wait_for(state="visible")` | `iframe.get_by_role("dialog").wait_for(state="visible", timeout=10000)` |
| Dialog closes | `dialog.wait_for(state="hidden")` | `dialog.wait_for(state="hidden", timeout=10000)` |
| Item created | `new_item.wait_for(state="visible")` | `service_row.wait_for(state="visible", timeout=10000)` |
| Item deleted | `item.wait_for(state="hidden")` | `deleted_row.wait_for(state="hidden", timeout=10000)` |
| Navigation | `page.wait_for_url(pattern)` | `page.wait_for_url("**/settings/services/**")` |
| Loading complete | `spinner.wait_for(state="hidden")` | `loader.wait_for(state="hidden", timeout=15000)` |
| Form ready | `field.wait_for(state="visible")` | `name_field.wait_for(state="visible", timeout=5000)` |

### Acceptable Small Delays

Only use `wait_for_timeout()` with small values (100-300ms) for:
- UI micro-animations where no element state changes
- Brief delay before typing (field transformation)

**Always pair with an element wait:**
```python
# CORRECT: Element wait + small delay for animation
dialog.wait_for(state="visible", timeout=10000)
page.wait_for_timeout(200)  # Brief animation settle

# WRONG: Fixed delay alone
page.wait_for_timeout(2000)  # Bad - no element verification
```

### Document in Script

Each step should include the wait condition:

```markdown
### Step 5: Click Save

**VERIFIED PLAYWRIGHT CODE**:
```python
save_btn.click()
# Wait for dialog to close
dialog.wait_for(state="hidden", timeout=10000)
```

- **Wait for**: Dialog closes (wait_for state="hidden")
```

## MCP Exploration Completeness Checklist

Before documenting any step in script.md, verify:

- [ ] **Full flow executed**: Ran the COMPLETE action sequence in MCP (not just individual steps)
- [ ] **End state verified**: Confirmed the final UI state matches expectations
- [ ] **State transitions checked**: If action changes UI (e.g., view to edit mode), verified ALL buttons/elements in new state
- [ ] **Exact code captured**: Copied the EXACT code from MCP's "Ran Playwright code" output
- [ ] **Text input uses press_sequentially()**: All fill() calls converted to click() + press_sequentially()
- [ ] **No assumptions made**: Did not assume element names/positions - verified each one
- [ ] **Wait condition identified**: For every action, identified what element indicates completion

### Common Mistakes to Avoid

1. **Assuming button names**: Always verify button text in MCP (e.g., "Close" vs "Save")
2. **Skipping state transitions**: A dialog may have different buttons when viewing vs editing
3. **Using fill() for text**: Always use the click() + press_sequentially() pattern
4. **Partial verification**: Testing only the happy path, not edge cases

## CRITICAL: Prerequisites

**NEVER create script.md without a complete steps.md file.**

Before generating script.md, verify:
1. `steps.md` exists and clearly defines WHAT the test should do
2. Each step in steps.md has a clear objective
3. You understand the full test flow before exploring

If steps.md is missing or unclear:
- STOP - do not generate script.md
- First create/clarify steps.md
- Then explore with MCP to generate script.md

## Generation Process

`script.md` is generated by:
1. Reading the goal from `steps.md`
2. AI explores the browser using MCP to achieve each step
3. **For each action: Run the Locator Decision Process**
   - Identify all locator options
   - Evaluate pros/cons of each
   - Choose the best option
   - **Validate it works in MCP**
   - Document the decision and verified code
4. Documenting wait conditions that worked
5. For function calls, referencing the function's script.md

## CRITICAL: No Unverified Code

**NEVER document code that wasn't tested in MCP.** Every `VERIFIED PLAYWRIGHT CODE` block must have been:
1. Actually executed in MCP
2. Confirmed to produce the expected result
3. The exact code from MCP's "Ran Playwright code" output (converted to Python syntax)

If you find yourself writing locator code without having tested it, STOP. Go to MCP and validate first.

## Cascade Effect

When `script.md` is updated:
1. Regenerate `test.py` from the updated script (copy VERIFIED PLAYWRIGHT CODE)
2. Log changes in `changelog.md`
3. If the flow changed significantly, consider updating `steps.md` too
